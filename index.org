# #+SETUPFILE: org-html-themes/setup/theme-readtheorg-local.setup
#+SETUPFILE: org-bootstrap-document/setup.org
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:t f:t inline:t num:3 p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+TITLE: Matematika skozi Python
#+DATE: <2017-01-26 čet>
#+AUTHOR: Martin Vuk
#+EMAIL: martin.vuk@fri.uni-lj.si
#+LANGUAGE: sl
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.1.1 (Org mode 9.0.3)
#+PROPERTY: header-args  :results output 
#+PROPERTY: header-args  :noweb strip-export 
* TODO Uvod 
Pred vami je priročnik o tem, kako uporabiti znanje matematike pri
programiranju. Priročnik je nastal kot dopolnilno gradivo pri predmetu
Matematika na Fakulteti za računalništvo in informatiko, Univerze v Ljubljani.

Priročnik spremljajo tudi naloge na portalu [[https://www.projekt-tomo.si/course/15/][projekt Tomo]], kjer lahko vsebino te
knjige tudi praktično preskusite. Z reševanjem teh nalog boste pridobili tako
znanje programiranja, kot tudi boljše razumevanje matematičnih pojmov. Obvezno
za vse, ki hočejo od predmeta nehttps://www.booking.com/searchresults.sl.html?aid=318615&label=New_English_EN_SI_27034554505-1rVfFD1JEcnh1S83ixwtIgS112436927905%3Apl%3Ata%3Ap1%3Ap2%3Aac%3Aap1t1%comedy central the daily show3Aneg%3Afi%3Atidsa-206305369705%3Alp9062551%3Ali%3Adec%3Adm&sid=ce0c7a70880dc9e6ad21237e55ce1188&age=10&age=6&checkin_monthday=25&checkin_year_month=2017-02&checkout_monthday=28&checkout_year_month=2017-02&class_interval=1&dest_id=-116829&dest_type=city&dtdisc=0&from_history=1&group_adults=2&group_children=2&hlrd=0&hyb_red=0&inac=0&label_click=undef&mcs=0&mih=0&nha_red=0&no_rooms=1&postcard=0&raw_dest_type=city&redirected_from_city=0&redirected_from_landmark=0&redirected_from_region=0&req_age=10&req_age=6&room1=A%2CA%2C10%2C6&sb_price_type=total&sh_position=2&si=ai&si=ci&si=co&si=di&si=la&si=re&ss_all=0&ssb=empty&sshis=0&rows=20&offset=20kaj več. Vabljeni ste tudi, da dodate
predme Matematika med svoje predmete, tako da kliknete na zvezdico nad imen Symbol’s value as variable is void: org-export-use-babelom
predmeta. 

Poleg tega so na voljo tudi kratki vide Symbol’s value as variable is void: org-export-use-babeli na YouTube kanalu.

** Kako brati to knjigo
Vsekakor priporočamo, da naloge poskusite rešiti phttps://www.booking.com/searchresults.sl.html?aid=318615&label=New_English_EN_SI_27034554505-1rVfFD1JEcnh1S83ixwtIgS112436927905%3Apl%3Ata%3Ap1%3Ap2%3Aac%3Aap1t1%3Aneg%3Afi%3Atidsa-206305369705%3Alp9062551%3Ali%3Adec%3Adm&sid=ce0c7a70880dc9e6ad21237e55ce1188&age=10&age=6&checkin_monthday=25&checkin_year_month=2017-02&checkout_monthday=28&checkout_year_month=2017-02&class_interval=1&dest_id=-116829&dest_type=city&dtdisc=0&from_history=1&group_adults=2&group_children=2&hlrd=0&hyb_red=0&inac=0&label_click=undef&mcs=0&mih=0&nha_red=0&no_rooms=1&postcard=0&raw_dest_type=city&redirected_from_city=0&redirected_from_landmark=0&redirected_from_region=0&req_age=10&req_age=6&room1=A%2CA%2C10%2C6&sb_price_type=total&sh_position=2&si=ai&si=ci&si=co&si=di&si=la&si=re&ss_all=0&ssb=empty&sshis=0&rows=20&offset=20ovsem samostojno. Rešitve so 
v začetku skrite, da vas ne bi premamile. Če se vam zatakne, si poglejte najprej
splošna, matematična navodila za rešitev naloge in poskusite vsaj programerski
del rešiti sami. Če tudi to ne gre, si le poglejte rešitev. Rešitve ne
kopirajte, ampak jo raje prepišete ali še bolje napišite sami. Tako bodo vaši
možgani imeli več od tega.

Knjiga je na voljo v različnih formatih

- [[file:index.html][HTML spletna stran]]
- [[file:index.pdf][PDF dokument]]
- predmet [[https://www.projekt-tomo.si/course/15/][Matematika]] na portalu [[https://www.projekt-tomo.si/][Projekt Tomo]]
- [[http:index.org][izvorna koda]] v obliki  [[https://orgmode.org][Org-mode]] za urejevalnik [[https://www.gnu.org/software/emacs/][Emacs]]
 

* TODO Zaporedja in vrste
** TODO Zaporedja
V vsakdanjem življenju pojem zaporedja pogosto pomeni seznam elementov, pri
katerem je pomemben vrstni red. Na primer zaporedje plesnih korakov v
koreografiji, zaporedje števil pri lotu ali pa zaporedje postajališč na liniji
mestnega prometa. Matematike seveda zanima vse kar je povezano z neskončnostjo,
zato si pod pojmom zaporedja predstavljamo neskončna zaporedja, ki jih formalno
definiramo kot funkcijo 

$$\mathbb{N}\to A,$$ 

ki vsakemu naravnemu številu $n$
priredi nek element $a_n=a(n)$ množice $A$. Element $a_n$ imenujemo $n$ - ti
člen zaporedja. 

V računalništvu si želimo, da se programi končajo, zato nas velikokrat zanimajo
le končna zaporedja. V Python-u so končna zaporedja najpogosteje predstavljena s
podatkovnim tipom ~list~, ki predstavlja končni seznam elementov. Z zankami
~for~ in ~while~ se lahko sprehodimo po elementih seznama in izvedemo zaporedje
ukazov. Najbližje pojmu neskončnega zaporedja sta [[https://wiki.python.org/moin/Iterator][iterator]] in [[https://wiki.python.org/moin/Generators][generator]], ki
predstavljata posplošitev kolekcij elementov, po katerih se lahko sprehajamo s
~for~ zanko.

*** TODO Zaporedje podano s formulo
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: naloga
    :END:
Zapiši približne vrednosti prvih 15 členov zaporedja $a_n=\frac{n-1}{n+1}$
**** Namig
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
    Uporabi zanko ~for n in range(15):~.
**** Rešitev 
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
    #+BEGIN_SRC python
      for n in range(15):
          print((n-1)/(n+1))
    #+END_SRC

    #+RESULTS:
    #+begin_example
    -1.0
    0.0
    0.3333333333333333
    0.5
    0.6
    0.6666666666666666
    0.7142857142857143
    0.75
    0.7777777777777778
    0.8
    0.8181818181818182
    0.8333333333333334
    0.8461538461538461
    0.8571428571428571
    0.8666666666666667
#+end_example

*** TODO Rekurzivno zaporedje
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: naloga
    :END:
Zaporedje je podano z rekurzivno formulo $$a_{n+1}=\frac{2a_n^3+2}{3a_n^2}$$ in
začetnim členom $a_0=3$. Zapiši prvih 10 členov zaporedja. Kaj opaziš? 
**** Rešitev
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
#+BEGIN_SRC python :results output
  an = 2
  print(an)
  for i in range(9):
      an = (2*an**3+2)/(3*an**2)
      print(an)
#+END_SRC

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example

Členi zaporedja se po 5. členu začnejo ponavljati. Zaporedje je očitno
*konvergentno*. Zadnjih nekaj členov so zelo dobri približki za *limito*.
**** Rešitev z generatorjem
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Za ilustracijo nalogo rešimo še z *generatorjem*. Generator je funkcija, ki je
posebne vrste tip *iteratorja*. *Iterator* je objekt, ki pozna metodo ~next()~
in ga lahko uporabimo v ~for~ zanki. Funkcijo spremenimo v *generator* z uporabo
ukaza ~yield~, ki je zelo podoben ukazu ~return~, le da se ob njegovem klicu
izvajanje funkcije zamrzne do naslednjega klica metode ~next()~. Z generatorjem
na ta način lahko definiramo tudi neskončna zaporedja oziroma zaporedja
poljubnih dolžin. 

#+BEGIN_SRC python :results output
  def zaporedje(n):
      "Generator za prvih n členov zaporedja an"
      an = 2
      while n>0:
          yield an
          an = (2*an**3+2)/(3*an**2)
          n -= 1

  for clen in zaporedje(10):
      print(clen)
#+END_SRC

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example
**** Rešitev z rekurzijo
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Zaporedje $a_n$ lahko definiramo tudi z rekurzivno funkcijo. Paziti moramo le,
da znotraj funkcije opravimo le en klic na isto funkcijo, sicer časovna
zahtevnost eksponentno narašča.
#+BEGIN_SRC python :results output
  def zaporedje(n):
      "Rekurzivna funkcija, ki definira rekurzivno zaporedje"
      if n<=0:
          return 2
      else:
          an = zaporedje(n-1)
          return (2*an**3+2)/(3*an**2) 

  for n in range(10):
      print(zaporedje(n))
#+END_SRC  

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example

Kljub temu, da smo se z enim rekurzivnim klicem funkcije izognili eksponentni
časovni odvisnosti, je pri večkratnih klicih funkcije ~zaporedje~ še vedno
precej odvečnih izračunov. Ob vsakem zaporednem klicu funkcije ponovno
izračunamo vse člene od prvega naprej. Časovna zahtevnost ~for~ zanke je tako
kvadratična, medtem ko je pri prejšnjih rešitvah časovna zahtevnost linearna. 
*** TODO Konvergenca
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: naloga
    :END:
Za zaporedje $$a_n=\frac{n^2+n-1}{1-2n^2},$$ poišči prvi člen $a_n$, ki se za
manj kot
$\varepsilon=\frac{1}{100}$ razlikuje od limite.
**** Namig
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Poišči najmanjše naravno število $n$, da bo $|a_n-a|<\varepsilon$, kjer je  
$$a=\lim_{n\to\infty}a_n=-\frac{1}{2}.$$ Uporabi zanko ~while~.
**** Rešitev
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
#+BEGIN_SRC python :results output
  n = 0
  a = -0.5
  eps = 0.01
  while abs((n**2+n-1)/(1-2*n**2)-a)>eps:
      n += 1
  print(n)
#+END_SRC

#+RESULTS:
: 50
**** Rešitev z generatorjem
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Za ilustracijo nalogo rešimo še z *generatorjem*. Generator je funkcija, ki je
posebne vrste tip *iteratorja*. *Iterator* je objekt, ki pozna metodo ~next()~
in ga lahko uporabimo v ~for~ zanki. Funkcijo spremenimo v *generator* z uporabo
ukaza ~yield~, ki je zelo podoben ukazu ~return~, le da se ob 

#+BEGIN_SRC python :results output
  def zaporedje():
      n = 0
      while True:
          yield n, (n**2+n-1)/(1-2*n**2)
          n += 1
  a = -0.5
  eps = 0.01

  for n, clen in zaporedje():
      if abs(clen-a)<eps:
          print(n)
          break
#+END_SRC

#+RESULTS:
: 50

** Vrste

*** TODO Delne vsote vrste
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: naloga
    :END:
Izpiši prvih 15 delnih vsot neskončne vrste 
$$\sum_{n=1}^\infty \frac{1}{2^n}.$$
Kateremu številu se zdi, da je enaka vsota neskončne vrste?

**** Namig
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
  V zanki ~for n in range(1,16):~ prištevaj člene zaporedja eni spremenljivki, ki vsebuje delne
  vsote.

**** Rešitev    
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
 Uporabimo preprosto zanko ~for~
 #+BEGIN_SRC python :results output
   S = 0
   for n in range(1,16):
       S += 1/2**n
       print(S)
 #+END_SRC

 #+RESULTS:
 #+begin_example
 0.5
 0.75
 0.875
 0.9375
 0.96875
 0.984375
 0.9921875
 0.99609375
 0.998046875
 0.9990234375
 0.99951171875
 0.999755859375
 0.9998779296875
 0.99993896484375
 0.999969482421875
 #+end_example

*** Vsota vrste
Za vrsto 
$$4\sum_{n=0}^\infty\left(-1\right)^n \frac{1}{1+2n}$$
je znano, da je njena vsota enaka številu $\pi$. Preveri, da delne vsote te
vrste res konvergirajo k $\pi$. Napiši program (funkcijo), ki za poljuben $\varepsilon > 0$
poišče $n$, od katerega so vse delne vsote za manj kot $\varepsilon$ oddaljene
od $\pi$. Svoj program preskusite za $\varepsilon=10^{-4}$. Za kako majhen
$\varepsilon$ se program izvede v manj kot nekaj sekundah (npr. 10s). 

**** Namig
Uporabite zanko ~while~, pri kateri preverite, če je trenutna delna vsota
oddaljena za manj kot $\varepsilon$ oddaljena od $\pi$.

**** Rešitev
#+BEGIN_SRC python :results output
  import time
  from math import pi
  def konvergenca(epsilon):
      """Funkcija poišče najmanjši n , za katerega je n-ta delna vsota vrste s členi 1/n^2
      za manj kot epsilon oddaljena od števila pi."""
      S = 0
      n = 0
      while abs(S-pi) > epsilon:
          S += (-1)**n*4/(1+2*n)
          n += 1
      return n-1
  zacetek = time.time()
  n = konvergenca(0.0001)
  print("n=%d (v %f sekundah)" % (n, time.time()-zacetek))
#+END_SRC

#+RESULTS:
: n=9999 (v 0.008709 sekundah)

* TODO Funkcije
** TODO Ničle funkcij in enačbe
Preskusili boste različne metode za iskanje ničel funkcije. Ničla funkcije
$f(x)$ je vrednost spremenljivke $x$ za katero $f(x)=0$.
*** TODO Ničle tabelirane funkcije
Za zvezno funkcija poznamo le nekaj posameznih vrednosti. Podana imamo dva
seznama enake dolžine ~x~ in ~y~, tako da velja ~y[i] == f(x[i])~.

Napišite funkcijo ~nicle(x,y)~, ki izračuna približne vrednosti ničel, tako da
funkcijo nadomesti z /linearnim zlepkom/ in izračuna ničle zlepka. Linearni zlepek
dobimo tako, da graf funkcije $f(x)$
nadomestimo z daljicami (linearno funkcijo $y=kx+n$) med točkami, ki so podane s
seznamoma ~x~ in ~y~.

Funkcija ~nicle(x,y)~ naj vrne seznam približkov za ničle, urejenih po velikosti. Primer:

#+BEGIN_SRC python :noweb strip-export :exports both
<<nicle>>
x = [-1, 0, 1, 2, 3]
y = [1, -1, 1, 2, 3]
print(nicle(x,y))
#+END_SRC

#+RESULTS:
: [-0.5, 0.5]
**** Matematična izpeljava
Označimo z $x_1,x_2,\ldots,x_n$ in z $y_1,y_2,\ldots, y_n$ vrednosti v tabelah
~x~ in ~y~. Za neznano zvezno funkcijo $f$ velja 
$$y_i=f(x_i).$$

Ker je $f4 zvezna, lahko z gotovostjo trdimo, da je ničla na intervalu
$[x_i,x_{i+1}]$, kjer sta $y_i$ in $y_{i+1}$ različnega predznaka. Najprej mora
funkcija ~nicle~ poiskati intervale, kjer se to zgodi.

Denimo, da je na intervalu $[x_i,x_{i+1}]$ ničla. Enačbo za odsek linearnega
zlepka na tem intervalu dobimo tako, da poiščemo enačbo premice skozi točki na
krajiščih $(x_i,y_i)$ in $(x_{i+1},y_{i+1})$. V resnici nas zanima le, pri
kateri vrednosti, premica seka os $x$. To najlažje določimo s podobnimi
trikotniki:

#+header: :exports results :file zlepek.png 
#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 400 
#+header: :packages '(("" "tikz")) :border 1em :results raw
#+begin_src latex
  % Define block styles
  \usetikzlibrary{arrows}
\definecolor{uququq}{rgb}{0.25,0.25,0.25}
\definecolor{xdxdff}{rgb}{0.49,0.49,1}
\definecolor{qqqqff}{rgb}{0,0,1}
\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
\draw[->,color=black] (-1,0) -- (6,0);
\foreach \x in {-1,1,2,3,4,5}
\draw[shift={(\x,0)},color=black] (0pt,-2pt);
\draw[color=black] (5.64,0.09) node [anchor=south west] { x};
\draw[->,color=black] (0,-5) -- (0,3);
\foreach \y in {-5,-4,-3,-2,-1,1,2}
\draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
\draw[color=black] (0.11,2.57) node [anchor=west] { y};
\clip(-1,-5) rectangle (6,3);
\draw (1,2)-- (4,-4);
\draw (1,2)-- (1,0);
\draw (4,-4)-- (4,0);
\draw (1,0)-- (4,0);
%\begin{scriptsize}
\fill [color=qqqqff] (1,2) circle (1.5pt);
\draw[color=qqqqff] (1.75,2.28) node {$(x_i,y_i)$};
\fill [color=qqqqff] (4,-4) circle (1.5pt);
\draw[color=qqqqff] (5.1,-3.7) node {$(x_{i+1},y_{i+1}})$};
\fill [color=xdxdff] (1,0) circle (1.5pt);
\draw[color=xdxdff] (1.42,0.28) node {$x_i$};
\draw[color=black] (0.96,1.16) node {$y_i$};
\fill [color=qqqqff] (4,0) circle (1.5pt);
\draw[color=qqqqff] (4.78,0.28) node {$x_{i+1}$};
\draw[color=black] (5.05,-1.83) node {$y_{i+1}$};
\fill [color=uququq] (2,0) circle (1.5pt);
\draw[color=uququq] (2.32,0.28) node {$x$};
%\end{scriptsize}
\end{tikzpicture}
#+end_src

#+RESULTS:
[[file:zlepek.png]]
**** Rešitev
#+name: nicle
#+BEGIN_SRC python 
  def nicle(x, y):
      x_n = []
      for i in range(len(x)-1):
          if y[i]*y[i+1]<0:
              nicla = (y[i+1]*x[i] - y[i]*x[i+1])/(y[i+1] - y[i])
              x_n.append(nicla)
      return x_n
#+END_SRC

#+RESULTS: nicle
**** Testi 
S spodnjo kodo lahko preskusite pravilnost delovanja vaše funkcije
#+BEGIN_SRC python :noweb strip-export
  <<nicle>>
  import unittest
  import random

  class NicleTest(unittest.TestCase):
      def test_primer(self):
          self.assertEqual(nicle([-1, 0, 1, 2, 3], [1, -1, 1, 2, 3]), [-0.5, 0.5])

  unittest.main()
#+END_SRC

#+RESULTS:

*** TODO Bisekcija
Če ima zvezna funkcija v krajiščih intervala različna predznaka, potem je na tem
intervalu zagotovo vsaj ena ničla. To dejstvo uporabi metoda bisekcije, s katero
lahko poiščemo ničle. 

Napišite funkcijo ~bisekcija(f, interval, eps)~, ki z bisekcijo poišče interval
dolžine največ eps, na katerem je ničla funkcije $f$. Krajišči začetnega intervala
sta podani v seznamu ~interval~. Funkcija naj vrne seznam s krajišči intervala. Če
vrednosti na intervalu nimajo različnega predznaka, naj funkcija javi napako
tipa ~ValueError~. 

Primer:

#+BEGIN_SRC python :noweb strip-export :results output :exports both
<<bisekcija>>
f = lambda x: x**2-2
print(bisekcija(f, (1,2), 0.3))
#+END_SRC

#+RESULTS:
: [1.25, 1.5]

#+BEGIN_SRC python :results output
  <<bisekcija>>
  try:
    f = lambda x: x**2-2
    bisekcija(f,(2,3),0.3)
  except ValueError as err:
    print(err)
#+END_SRC

#+RESULTS:
: Vrednosti v krajiščih nimajo različnih predznakov

ValueError: Na intervalu ni ničle.

**** Rešitev
#+name: bisekcija 
#+BEGIN_SRC python
  def bisekcija(f, interval, eps):
      a,b = interval
      fa, fb = (f(a),f(b))
      if fa*fb > 0:
          raise(ValueError("Vrednosti v krajiščih nimajo različnih predznakov"))
      while abs(b-a) > eps:
          c = (a+b)/2
          fc = f(c)
          if fa*fc < 0:
              b, fb = c, fc
          elif fb*fc <0:
              a, fa = c, fc
          elif fc == 0:
              return [c,c]
      return [a,b]
#+END_SRC
+RESULTS: bisekcija
: None

**** Testi

#+BEGIN_SRC python
  <<bisekcija>>
  import unittest
  class BisekcijaTest(unittest.TestCase):
        def test_primer(self):
            f = lambda x: x**-2
            self.assertEqual(bisekcija(f,[1,2],0.3),[1.25,1.5])

  unittest.main()
#+END_SRC

*** TODO Sekantna metoda
S sekantno metodo konstruiramo zaporedje približkov, ki se približujejo ničli
funkcije, tako da začnemo z dvema približkoma, izračunamo presečišče sekante
skozi dve točki na grafu funkcije in

Primer:
#+BEGIN_SRC python :exports both :results output
<<sekantna>>
f = lambda x: x*x-2
print(sekantna(f,1,2,1e-5))
print(2**0.5)
#+END_SRC

#+RESULTS:
: 1.4142135620573204
: 1.4142135623730951

**** Rešitev
#+name: sekantna
#+BEGIN_SRC python
  def sekantna(f,a,b,eps, maxit=100):
      for n in range(maxit):
          fa, fb = f(a), f(b)
          b, a = b - fb*(b-a)/(fb-fa), b
          if abs(fb)<eps:
              return b,n
      return None,maxit
#+END_SRC

#+RESULTS: sekantna
: None

** Izračun vrednosti polinoma
*** Hornerjev algoritem
** Kotne funkcije
*** Tabela kotnih funkcij
Napiši program, ki generira tabeli kotnih funkcij $\sin$ in $\cos$ na intervalu
$[0,2\pi]$  v točkah $$x_i=i\frac{\pi}{100};\quad i=0,\ldots, 200.$$ Uporabi
adicijske izreka za sinus in cosinus
\begin{eqnarray*}
\sin(x+y)&=&\sin(x)\cos(y)+\sin(y)\cos(x)\\
\cos(x+y)&=&\cos(x)\cos(y) - \sin(x)\sin(y)
\end{eqnarray*}
in približne vrednosti
 $\sin(\frac{\pi}{100})\simeq \frac{\pi}{100}$ 
src_octave{disp(sin(pi/100))} {{{results(= 0.031411=)}}}
$\cos(\frac{\pi}{100})\simeq 1$
src_python{import math; return math.cos(math.pi/100)} {{{results(=0.9995065603657316=)}}}.

Dobljene vrednosti primerjaj z vrednostmi, ki jih vrneta funkciji ~math.sin~
in ~math.cos~, tako da poiščete razlike. Kolikšna je največja razlika med
vrednostjo, ki jo je izračunal vaš program in vrednostjo, ki jo je dala vgrajena
funkcija?   
*** Sinus in kosinus 1
Napiši funkcijo, ki izračuna vrednost funkcije $\sin(x)$ in $\cos(x)$ na
intervalu $[0,\frac{\pi}{2}]$, tako da uporabiš
adicijska izreka za dvojni kot
$$\sin(2x) = 2\sin(x)\cos(x),\quad \cos(2x)=\cos^2(x)-\sin^2(x)$$  
 in za majhne $x$ upošteva približni enakosti
$$\sin(x)\simeq x\text{ in } \cos(x)\simeq 1;\quad |x|<10^{-1}.$$
*** Sinus in kosinus 2
Funkcijo iz prejšnje naloge razširi na vsa realna števila. Uporabi periodičnost
in simetrije funkcij $\sin$ in $\cos$.
* TODO Odvod
** TODO Simbolično odvajanje

Naloga ilustrira kako deluje simbolično odvajanje.
Napisati želimo funkcijo v Pythonu, ki izračuna odvod dane funkcije f.
Pri tem se omejimo le na funkcije, ki jih je mogoče izraziti z
osnovnimi operacijami ~+~, ~-~, ~*~, ~/~, s potenco ~a^b~ in funkcijami
~sin~, ~cos~, ~exp~ in ~log~.
Da bo programiranje lažje, bomo funkcijo zapisali v
[[http://sl.wikipedia.org/wiki/Obrnjeni_poljski_zapis][obrnjeni poljki notaciji]]([[http://en.wikipedia.org/wiki/Reverse_Polish_notation][uporabili bomo angleško kratico RPN]]).
*** TODO RPN
Napiši razred ~RPN~, ki predstavlja funkcijo spremenljivke ~x~
podano v RPN obliki.
Razred naj ima atribut ~izraz~, ki naj bo niz oblike

#+BEGIN_EXAMPLE
    'arg1 arg2 op1 arg3 ... argn funk',
#+END_EXAMPLE

sestavljen iz besed, ločenih s presledki, ki so

 - argumenti: število ali ~'x'~,
 - operacije: ~'+'~, ~'-'~, ~'*'~, ~'/'~ ali ~'^'~
 - funkcije: ~'sin'~, ~'cos'~, ~'exp'~ ali ~'log'~.

Osnovne operacije zapišemo s 3 besedami

#+BEGIN_EXAMPLE
    1 + 1   -> '1 1 +'
    1 - 2   -> '1 2 -'
    2 * 3   -> '2 3 *'
    2 / 3   -> '2 3 /'
    2 ^ 3   -> '2 3 ^'
#+END_EXAMPLE
Funkcije ~sin~, ~cos~, ~exp~, ~log~ pa zapišemo z dvema besedama:

#+BEGIN_EXAMPLE
    sin(3.14) -> '3.14 sin'
    e^2.5     -> '2.5 exp'
#+END_EXAMPLE
Primeri
#+BEGIN_EXAMPLE
    1 + 2 + 3       -> '1 2 3 + +' ali '1 2 + 3 +'
    sin(2x)         -> '2 x * sin'
    sqrt(x)         -> 'x 0.5 ^'
    (x+1)/(x-1)     -> 'x 1 + x 1 - /'
    x^2+2x-1        -> 'x 2 ^ 2 x * -1 + +'
    log(sin(2/x+1)) -> '2 x / 1 + sin log'
#+END_EXAMPLE
Razred naj ima metodo ~__init__(izraz)~, ki inicializira atribut ~izraz~ in
metodo ~vrednost(arg)~, ki naj vrne vrednost izraza, če spremenljivko ~x~
zamenjamo z dano vrednostjo ~arg~.

Primer:

    >>> f = RPM('1 x +')
    >>> f.vrednost(1)
    2.0
**** Rešitev
#+BEGIN_SRC python

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()

#+END_SRC
**** Testi
#+BEGIN_SRC python
Check.part()
from math import sin
Check.equal("RPN('2 x *').vrednost(3)", 6)
Check.equal("RPN('2 x *').vrednost(-3)", -6)
Check.equal("RPN('1 x 2 ^ sin +').vrednost(3)", 1+sin(3**2))
Check.equal("RPN('1 x 2 ^ sin +').vrednost(3.14)", 1+sin(3.14**2))
f = RPN('x 1 + x 2 ^ / 3 x * 4 -')
g = RPN('x log sin cos exp')
for x in range(3):
    Check.secret(f.vrednost(x/4+1))
    Check.secret(g.vrednost(x/3+1))
#+END_SRC
*** TODO Prikaz RPN izraza  
Razredu ~RPN~ dodaj metodo ~__str__~, ki vrne izraz zapisan klasično z
oklepaji in operatorji.
Primer:

    >>> f = RPM.new('3 x 2 x ^ + /')
    >>> print(str(f))
    (3/(x+(2^x)))
**** Rešitev
#+BEGIN_SRC python

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()
    def __str__(self):
        sklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = '(' + str(a) + beseda + str(b) + ')'
                sklad.append(rezultat)
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = beseda + '(' + str(a) + ')'
                sklad.append(rezultat)
            else:
                sklad.append(str(beseda))
        return sklad.pop()

#+END_SRC
**** Testi
#+BEGIN_SRC python

Check.part()
Check.equal("str(RPN('2 x *'))", '(2*x)')
Check.equal("str(RPN('2 x x 3 ^ + *'))", '(2*(x+(x^3)))')
Check.equal("str(RPN('2 sin x x 3 ^ + *'))",'(sin(2)*(x+(x^3)))')
Check.secret(str(RPN('1 x cos x ^ sin +')))
Check.secret(str(RPN('1 log x / sin x +')))

#+END_SRC
*** TODO Odvod RPN
Razredu ~RPN~ dodaj metodo ~odvod~, ki vrne objekt istega razreda, ki vsebuje
izraz za odvod po spremenljivki ~x~.

Primer:

    >>> f = RPM.new('1 x +')
    >>> df = f.odvod()
    >>> print(df.vrednost(1))
    1.0

Testnih primerov ne bomo navajali, ker je možno nalogo rešiti na več načinov,
pri katerih bo izraz za odvod različen (čeprav pravilen).
Za ilustracijo si poglejmo izraze

#+BEGIN_EXAMPLE
    '1 x +', 'x 1 +' in '1 x 1 + *',
#+END_EXAMPLE

ki oba predstavljajo isto funkcijo ~f(x)=x+1~.
Testirmo tako, da izračunamo vrednost odvoda v nekaj naključno izbranih
fiksnih točkah, s čimer pravilnost odvoda precej dobro preverimo.

Dovolj je, da metoda ~odvod~ deluje za izraze, ki ne vsebujejo potence ~'^'~.

**** Rešitev
#+BEGIN_SRC python

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    fodvod = {'sin': 'cos','cos':'sin -1 *','exp':'exp','log':'-1 ^'}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()
    def __str__(self):
        sklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = '(' + str(a) + beseda + str(b) + ')'
                sklad.append(rezultat)
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = beseda + '(' + str(a) + ')'
                sklad.append(rezultat)
            else:
                sklad.append(str(beseda))
        return sklad.pop()
    def odvod(self):
        dfsklad = []
        fsklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                df = dfsklad.pop()
                dg = dfsklad.pop()
                f = fsklad.pop()
                g = fsklad.pop()
                if beseda in ['+','-']:
                    # (f+g)' = f'+g'
                    df = ' '.join((df, dg, beseda))
                elif beseda == '*':
                    # (f*g)' = f'g + g'f
                    df = ' '.join((dg, f, '*', df, g, '* +'))
                elif beseda == '/':
                    df = ' '.join((g, df, '*', f, dg,'* -', g, '2 ^ /'))
                dfsklad.append(df)
                fsklad.append(' '.join((f, g, beseda)))
            elif beseda in self.funkcije.keys():
                # verižno pravilo (f(g(x)) = f'(x)*g'(x))
                df = dfsklad.pop()
                f = fsklad.pop()
                df = ' '.join((df,f,self.fodvod[beseda],'*'))
                dfsklad.append(df)
                fsklad.append(' '.join((f,beseda)))
            elif beseda == 'x':
                dfsklad.append('1')
                fsklad.append('x')
            else:
                dfsklad.append('0')
                fsklad.append(beseda)
        return RPN(dfsklad.pop())

#+END_SRC
**** Testi
#+BEGIN_SRC python

Check.part()
from math import log,sin,cos
izraz = "RPN('x cos x log *').odvod()"
xi = (1.2,2.3,5,10.1,0.876,22.9876)
for x in xi:
    Check.equal(izraz + '.vrednost(%f)'%x ,cos(x)/x-log(x)*sin(x))
    Check.secret(RPN('x sin x cos /').odvod().vrednost(x))
    Check.secret(RPN('1 x sin + x 2 * log /').odvod().vrednost(x))

#+END_SRC
*** TODO Odvod potence
Dopolni metodo ~odvod~, da deluje tudi za izraze, ki vsebujejo potenco ~^~

Primer:

    >>> f = RPM('x 2 ^')
    >>> df = f.odvod()
    >>> print(df.vrednost(1))
    2.0
    >>> RPN('2 x ^').odvod().vrednost(0) # vrniti mora log(2)
    0.6931471805599453
**** Rešitev
#+BEGIN_SRC python

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    fodvod = {'sin': 'cos','cos':'sin -1 *','exp':'exp','log':'-1 ^'}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()
    def __str__(self):
        sklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = '(' + str(a) + beseda + str(b) + ')'
                sklad.append(rezultat)
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = beseda + '(' + str(a) + ')'
                sklad.append(rezultat)
            else:
                sklad.append(str(beseda))
        return sklad.pop()
    def odvod(self):
        dfsklad = []
        fsklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                dg = dfsklad.pop()
                df = dfsklad.pop()
                g = fsklad.pop()
                f = fsklad.pop()
                if beseda in ['+','-']:
                    # (f+g)' = f'+g'
                    df = ' '.join((df, dg, beseda))
                elif beseda == '*':
                    # (f*g)' = f'g + g'f
                    df = ' '.join((dg, f, '*', df, g, '* +'))
                elif beseda == '/':
                    df = ' '.join((g, df, '*', f, dg,'* -', g, '2 ^ /'))
                elif beseda == '^':
                    # f(x)^g(x)' =f(x)^(g(x)-1)*(f(x)*log(f(x)*g'(x))+g(x)*f'(x))
                    df = ' '.join((f, g, '1 - ^', dg, f, f, 'log * *', df, g, '* + *'))
                dfsklad.append(df)
                fsklad.append(' '.join((f, g, beseda)))
            elif beseda in self.funkcije.keys():
                # verižno pravilo (f(g(x)) = f'(x)*g'(x))
                df = dfsklad.pop()
                f = fsklad.pop()
                df = ' '.join((df,f,self.fodvod[beseda],'*'))
                dfsklad.append(df)
                fsklad.append(' '.join((f,beseda)))
            elif beseda == 'x':
                dfsklad.append('1')
                fsklad.append('x')
            else:
                dfsklad.append('0')
                fsklad.append(beseda)
        return RPN(dfsklad.pop())

#+END_SRC
**** Testi

#+BEGIN_SRC python
Check.part()
from math import log,sin,cos
x = 1.2
xi = (0.1,1.2,2.3,1.1398,1.87,2.9876)
izraz1 = "RPN('x 1 + x log ^').odvod()"
izraz2 = "RPN('x x ^').odvod()"

for x in xi:
    Check.equal(izraz1 + '.vrednost(%f)'%x,(x+1)**log(x)*(log(x)/(x+1)+log(x+1)/x))
    Check.equal(izraz2 + '.vrednost(%f)'%x, x**x*(log(x)+1))
    Check.secret(RPN("1 x + x x * ^").odvod().vrednost(x))
#+END_SRC

** TODO Avtomatsko odvajanje
Naloge ilustrirajo, kako deluje [[https://en.wikipedia.org/wiki/Automatic_differentiation][avtomatsko odvajanje]] računalniških programov.
*** TODO Preprosta funkcija
Funkcija $f$ je podana s Python definicijo
#+BEGIN_SRC python
def f(x):
    y = x**2
    return y
#+END_SRC
Sestavite funkcijo ~df(x)~, ki vrne vrednost odvoda funkcije f
izračunanega v točki ~x~.
Na primer:

    >>> df(1)
    2
    >>> df(2)
    4
**** Rešitev
#+BEGIN_SRC python
def df(x):
    return 2*x
#+END_SRC
**** Testi
#+BEGIN_SRC python

Check.part()
Check.equal('df(3)', 6)
Check.equal('df(0.2)', 2*0.2)
Check.equal('df(-1)', -2)
Check.secret(df(42))
Check.secret(df(-123))

#+END_SRC
*** TODO Malce bolj zapletena funkcija
Funkcija ~g(x)~ je podana s Python definicijo
#+BEGIN_SRC python
    def g(x):
      y = x**2
      y = x*(1/y+y)
      return y
#+END_SRC

Sestavite funkcijo ~dg(x)~, ki vrne vrednost odvoda ~g'(x)~ funkcije ~g~
izračunanega v točki ~x~. Končni rezultat zaokrožite z ~round(y,10)~,
preden ga funkcija ~dg~ vrne.

Na primer:
#+BEGIN_SRC python
    >>> dg(1)
    2
    >>> dg(2)
    11.75
#+END_SRC
**** Rešitev
#+BEGIN_SRC python
# definicija z odvajanjem kode
def dg(x):
    dy = 2*x
    y = x**2
    dy = (1/y+y)+x*(1-1/y**2)*dy
    y = x*(1/y+y)
    return round(dy,10)
#+END_SRC
**** Testi
#+BEGIN_SRC python
# Definicija s formulo
def dg_formula(x):
    return round(x**2 + x*(2*x - 2/x**3) + x**(-2),10)
#+END_SRC
#+BEGIN_SRC python

Check.equal('dg(-1)', 2)
try:
    dg(0)
    Check.error("Klic dg(0) mora javiti napako!")
except:
    pass
# Testi za dg
#Testi za dg
cases = [(0.5, -3.25), (-0.5, -3.25), (1, 2.0), (-1, 2.0), (2, 11.75), (-2, 11.75), (4, 47.9375), (-4, 47.9375)]
for case in cases:
    x,dgv = case
    Check.equal('dg(%f)'% x, dgv)
Check.equal('dg(0.5)',-3.25)
Check.equal('dg(-4)', 47.9375)
Check.secret(dg(42))
for x in range(2,30,3):
    Check.secret(dg(x))
#+END_SRC
*** TODO For zanka
Funkcija ~h(x)~ je podana s Python definicijo
#+BEGIN_SRC python

    def h(x):
      y = 1
      for n in range(10):
        y = (x/y+y)/2
      return y
#+END_SRC

Sestavite funkcijo ~dh(x)~, ki vrne vrednost odvoda funkcije g
izračunanega v točki ~x~. Končni rezultat zaokrožite z ~round(y,10)~.

Na primer:
#+BEGIN_SRC python
    >>> dh(1)
    0.5
    >>> dh(4)
    0.25
#+END_SRC
**** Namig
Predelajte kodo za funkcijo ~h~ tako, da hkrati s
funkcijo računate še njen odvod. Vsaki vrstici kode dodajte
vrstico v kateri posodobite vrednost odvoda.
Katera pravila za odvajanje morate uporabiti?
**** Rešitev
#+BEGIN_SRC python
def dh(x):
    y = 1
    dy = 0
    for n in range(10):
        dy = ((1*y-dy*x)/y**2+dy)/2
        y = (x/y+y)/2
    return round(dy,10)
#+END_SRC
**** Testi
#+BEGIN_SRC python
# funkcija h v resnici računa x^(1/2) z Haronovim obrazcem (tangentno metodo)
def dh_aprox(x):
    return round(x**(-0.5)/2,10)
#+END_SRC
#+BEGIN_SRC python
Check.part()
# Testi za dh
cases =  [(2, 0.3535533906, 0.7071067812),
          (3, 0.2886751346, 0.8660254038),
          (4, 0.25, 1.0),
          (5, 0.2236067977, 1.1180339887),
          (6, 0.2041241452, 1.2247448714),
          (7, 0.1889822365, 1.3228756555),
          (8, 0.1767766953, 1.4142135624),
          (9, 0.1666666667, 1.5)]
for case in cases:
    x,dh1,dh2 = case
    Check.equal('dh(%d)'% x, dh1)
    Check.equal('dh(1/%d)'% x,dh2)
for x in range(1,30,3):
    Check.secret(dh(x/10))
#+END_SRC
*** TODO Kompozitum funkcij
Funkcija ~k~ je podana s pomožno funkcijo ~r(x)~
#+BEGIN_SRC python
        def r(x):
            y = 1
            for i in range(1,10):
                y = x+y
                y = 1/(i*y)
            return y
        def k(x):
            y = x
            for i in range(5):
                y = x*r(y)**2
            return y
#+END_SRC

Sestavite funkcijo ~dr(x)~ za ki izračuna odvod ~r'(x)~ in
~dk(x)~, ki vrne vrednost odvoda ~k'(x)~
izračunanega v točki ~x~.
Končni rezultat zaokrožite z ~round(y,10)~.

Na primer:
#+BEGIN_SRC python
    >>> dr(10)
    -0.001106963
    >>> dk(4)
    -0.0034362142
#+END_SRC

**** Namig
V ~dk(x)~ uporabite funkcijo ~dr(x)~ in verižno pravilo.
**** Rešitev
#+BEGIN_SRC python

def r(x):
    y = 1
    for i in range(1,10):
        y = x+y
        y = 1/(i*y)
    return y
def k(x):
    y = x
    for i in range(5):
        y = x*r(y)**2
    return y
def dr(x):
    y = 1
    dy = 0
    for i in range(1,10):
        dy = 1+dy
        y = x+y
        dy = -(i*y)**(-2)*i*dy
        y = 1/(i*y)
    return round(dy,10)

def dk(x):
    y = x
    dy = 1
    for i in range(5):
        z = r(y)
        dy = z**2+x*2*z*dr(y)*dy
        y = x*z**2
    return round(dy,10)

#+END_SRC
**** Testi
#+BEGIN_SRC python 

Check.part()
def drsym(x):
    return round(-(1625702400*x**16 + 3251404800*x**15 + 9852917760*x**14 + 13203025920*x**13 + 20623343616*x**12 + 19717742592*x**11 + 19865630592*x**10 + 13868455680*x**9 + 9604790272*x**8 + 4865480192*x**7 + 2321094784*x**6 + 820537216*x**5 + 256614880*x**4 + 57572480*x**3 + 10056136*x**2 + 898800*x + 240360)/(14631321600*x**18 + 29262643200*x**17 + 94163005440*x**16 + 129800724480*x**15 + 218471779584*x**14 + 221236075008*x**13 + 246177055872*x**12 + 188496315648*x**11 + 149388195600*x**10 + 86951121696*x**9 + 50053354416*x**8 + 21790548000*x**7 + 8964450216*x**6 + 2790466560*x**5 + 772383960*x**4 + 155310120*x**3 + 24824025*x**2 + 2485350*x + 99225),10)

def dk_fd(x):
    # finite diference method for derivative
    h = 2**(-20)
    dy = -k(x+2*h)+8*k(x+h)-8*k(x-h)+k(x-2*h)
    dy = dy/12/h
    return round(dy,10)

try:
    dr(-1)
    Check.error("Klic dr(-1) bi moral javiti napako!")
except:
    pass
Check.equal('dk(4)',-0.0034362142)

# Testi za dr in dk
cases =  [(0, -2.4223733938, 0.0557006013),
          (2, -0.025432294, 0.0892606704),
          (3, -0.0118554566, 0.0981358769),
          (5, -0.004378945, 0.1103474705),
          (6, -0.0030546628, 0.1148118927),
          (9, -0.0013654262, 0.12455767)]
for case in cases:
    x, drv, dkv = case
    Check.equal('dr(%d)'%x, drv)
    Check.equal('dk(1/%d)'%(x+1),dkv)
for x in range(1,30,3):
    Check.secret(dk(x/10))
    Check.secret(dr(x/10))
#+END_SRC
*** TODO Program kot zaporedje(kompozitum) preprostih operacij
** TODO Numerično odvajanje
** TODO Tangenta in normala
* TODO Integral
** TODO Nedoločeni integral
*** TODO Integral polinoma
Napiši funkcijo ~integral(p)~, ki izračuna integral polinoma ~p~. Polinom 
$$p(x) = a_n x^n + a_{n-1}x^{n-1}+\ldots + a_1 + a_0$
naj bo podan s seznamom koeficientov ~p~ $=[a_n,a_{n-1},\ldots a_0]$.

Primer:

#+BEGIN_SRC python :exports both :results output
<<integral>>
p = [4,3,2,1] # polinom x^3 + 2 x^2 +3x +4
print(integral(p))
#+END_SRC

#+RESULTS:
: [1.0, 1.0, 1.0, 1.0, 0]

**** Rešitev
#+name: integral
#+BEGIN_SRC python
  def integral(p):
      n = len(p)
      return [p[i]/(n-i) for i in range(n)] + [0]
#+END_SRC
** TODO Določeni integral
*** TODO Trapezna formula za določeni integral
Napiši funkcijo ~trapez(f,a,b,n)~, ki izračuna približek integrala
$$\int_a^bf(x)dx.$$ kot vsoto ploščin trapezov, ki jih dobimo, če interval
$[a,b]$ razdelimo na podintervale $[x_i,x_{i+1}]$ enake dolžine in povežemo
točke $(x_i,0)$, $(x_{i+1},0)$, $(x_{i+1},f(x_{i+1}))$ in $(x_i,f(x_i))$ (glej
sliko).

#+header: :imagemagick yes :iminoptions -density 1000 :imoutoptions -geometry 600 
#+header: :exports results :file trapez.png
#+header: :packages '(("" "pgfplots")) :border 1em :results raw
#+header: :header '("\\pgfplotsset{compat=newest}")
#+BEGIN_SRC latex
\pgfplotsset{
    integral axis/.style={
        axis lines=middle,
        enlarge y limits=upper,
        axis equal image, width=12cm,
        xlabel=$x$, ylabel=$y$,
        ytick=\empty,
        xticklabel style={font=\small, text height=1.5ex, anchor=north},
        samples=100
    },
    integral/.style={
            domain=2:10,
            samples=5
    },
    integral fill/.style={
            integral,
            draw=none, fill=#1,
            %on layer=axis background
        },
        integral fill/.default=gray!10,
        integral line/.style={
            integral,
            very thick,
            draw=#1
        },
        integral line/.default=black
}


\begin{tikzpicture}[
    % The function that is used for all the plots
    declare function={f=(2*x^3-33*x^2+144*x)/50;}
]
\begin{axis}[
    integral axis,
    ymin=0,
    xmin=0.75, xmax=11.25,
    domain=1.5:10.5,
    xtick={2,...,10},
    xticklabels={$a$,,$\ldots$,,$x_{i}$,,$x_{i+1}$,,$b$},
    axis on top
]
% The filled area under the approximate integral
\addplot [integral fill=gray!15] {f} \closedcycle;

% The highlighted segment
\addplot [integral fill=gray!35, domain=6:8, samples=2] {f} \closedcycle;

% The function
\addplot [very thick, blue!75] {f} node [anchor=south] {$y=f(x)$};

% The approximate integral
\addplot [integral line=black] {f};

% The vertical lines between the segments
\addplot [integral, ycomb] {f};

\end{axis}
\end{tikzpicture}
#+END_SRC

#+RESULTS:
[[file:trapez.png]]
Primer:
#+BEGIN_SRC python :results output :exports both
  <<trapez>>
  f = lambda x: x**2 
  print(trapez(f,0,1,1))
#+END_SRC

#+RESULTS:
: 0.5
**** Namig
Velja
$$\int_{x_i}^{x_{i+1}}f(x)dx=\int_{a}^{x_{1}}f(x)dx+\int_{x_1}^{x_{2}}f(x)dx+\ldots
\int_{x_{n-1}}^{b}f(x)dx,$$
S formulo za izračun ploščine trapeza
$$P=v\frac{a+b}{2}$$ izpeljite približek za integral
$$\int_{x_i}^{x_{i+1}}f(x)dx$$
in formulo za integral na intervalu $[a,b]$ dobite kot vsoto ploščin posameznih
trapezov. 
**** Matematična izpeljava
Če interval $[a,b]$ razdelimo na $n$ enakih delov, lahko krajišča podintervalov
izračunamo kot $x_i = a+ih$, kjer je $h=\frac{b-a}{n}$ dolžina podintervala.
Ploščina trapeza z oglišči $(x_i,0)$, $(x_{i+1},0)$, $(x_{i+1},f(x_{i+1}))$ in
$(x_i,f(x_i))$ je enaka
$$(x_{i+1}-x_i)\frac{f(x_i)+f(x_{i+1})}{2}=h\frac{f(x_i)+f(x_{i+1})}{2}.$$
Integral lahko torej približno ocenimo z vsoto 
 
 $$\int_a^bf(x) dx \simeq \sum_{i=0}^{n-1} h\frac{f(x_{i+1})+f(x_i))}{2}
= \frac{h}{2}\sum_{i=0}^{n-1}(f(x_i)+f(x_{i+1})).$$ 
Vsoto lahko preuredimo
\begin{multline*}
\frac{h}{2}\sum_{i=0}^{n-1}\left(f(x_i)+f(x_{i+1})\right)=\frac{h}{2}\left(\sum_{i=0}^{n-1}f(x_i)+\sum_{i=0}^{n-1}f(x_{i+1})\right)=\\
\frac{h}{2}\left(\sum_{i=0}^{n-1} f(x_i) + \sum_{i=1}^{n}f(x_i)\right) = 
\frac{h}{2}\left(f(a)+2\sum_{i=1}^{n-1}f(x_i)+f(b)\right),
\end{multline*}
tako, da se vrednost $f(x_i)$ pojavi le enkrat. Tako dobimo 
/sestavljeno trapezno pravilo/ za izračun integrala
$$
\int_a^bf(x)dx \simeq \frac{h}{2}\left(f(a)+2\sum_{i=1}^{n-1}f(x_i)+f(b)\right).
$$
 
**** Rešitev
#+name: trapez
#+BEGIN_SRC python
  def trapez(f,a,b,n):
      h = (b-a)/n
      return h/2*(f(a)+2*sum(f(a+(i+1)*h) for i in range(n-1))+f(b))
#+END_SRC

**** Testi
*** TODO Dolžina loka krivulje
Napiši funkcijo ~dolzina(f,a,b,n)~, ki izračuna dolžino loka grafa funkcije
$f(x)$ kot vsoto dolžin daljic, ki jih dobimo, če razdelimo interval $[a,b]$ na
podintervale $[x_i,x_{i+1}]$ enake dolžine in povežemo točke
$$(x_i,f(x_i))$ (glej sliko). 

Rezultat primerjaj s približkom, ki ga dobiš, če
uporabiš formulo za dolžino loka
$$l=\int_a^b \sqrt{1+f'(x)^2}dx$$
in trapezno formulo za izračun integrala.

#+header: :imagemagick yes :iminoptions -density 1000 :imoutoptions -geometry 600 
#+header: :exports results :file dolzina.png
#+header: :packages '(("" "pgfplots")) :border 1em :results raw
#+header: :header '("\\pgfplotsset{compat=newest}")
#+BEGIN_SRC latex
\pgfplotsset{
    integral axis/.style={
        axis lines=middle,
        enlarge y limits=upper,
        axis equal image, width=12cm,
        xlabel=$x$, ylabel=$y$,
        ytick=\empty,
        xticklabel style={font=\small, text height=1.5ex, anchor=north},
        samples=100
    },
    integral/.style={
            domain=2:10,
            samples=5
    },
    integral fill/.style={
            integral,
            draw=none, fill=#1,
            %on layer=axis background
        },
        integral fill/.default=gray!10,
        integral line/.style={
            integral,
            very thick,
            draw=#1
        },
        integral line/.default=black
}


\begin{tikzpicture}[
    % The function that is used for all the plots
    declare function={f=(2*x^3-33*x^2+144*x)/50;}
]
\begin{axis}[
    integral axis,
    ymin=0,
    xmin=0.75, xmax=11.25,
    domain=2:10,
    xtick={2,...,10},
    xticklabels={$a$,,$\ldots$,,$x_{i}$,,$x_{i+1}$,,$b$},
    axis on top
]
% The filled area under the approximate integral
% \addplot [integral fill=gray!15] {f} \closedcycle;

% The highlighted segment
% \addplot [integral fill=gray!35, domain=6:8, samples=2] {f} \closedcycle;

% The function
\addplot [very thick, blue!75] {f} node [anchor=south] {$y=f(x)$};

% The approximate integral
\addplot [integral line=black] {f};

% The vertical lines between the segments
% \addplot [integral, ycomb] {f};

\end{axis}
\end{tikzpicture}
#+END_SRC

#+RESULTS:
[[file:dolzina.png]]

Primer:
#+BEGIN_SRC python :exports both :results output 
<<trapez>>
<<dolzina>>
f = lambda x: x**2
print(dolzina(f,0,1,1))
#+END_SRC

#+RESULTS:
: 1.4142135623730951
#+BEGIN_SRC python :exports both :results output 
  <<trapez>>
  <<dolzina>>
  f = lambda x: x**2
  for n in range(5):
      print(dolzina(f,0,1,2**(2*n)))
#+END_SRC

#+RESULTS:
: 1.4142135623730951
: 1.4742804757093162
: 1.4786516869545336
: 1.4789246603146189
: 1.4789417202213675
Primerjamo še s trapezno formulo
#+BEGIN_SRC python :exports both :results output 
  <<trapez>>
  <<dolzina>>
  dl = lambda x: (1+4*x**2)**0.5
  for n in range(5):
      print(trapez(dl,0,1,2**(2*n)))
#+END_SRC

#+RESULTS:
: 1.618033988749895
: 1.4882642944012199
: 1.479525185093328
: 1.478979251951247
: 1.4789451321908484
**** Namig
Dolžina daljice med točkama $(x_0,y_0)$ in $(x_1,y_1)$ je enaka
$$\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}.$$
**** Rešitev
Označimo s $h=x_{i+1}-x_i$ dolžino podintervalov. Razdalja med $(x_i,f(x_i))$ in
$(x_{i+1},f(x_{i+1}))$ je tako enaka
$$ \sqrt{h^2+(f(x_{i+1})-f(x_i))^2}.$$
#+name: dolzina
#+BEGIN_SRC python
  def dolzina(f,a,b,n):
      h = (b-a)/n
      d = 0
      for i in range(n):
          dy = f(a+(i+1)*h) - f(a+i*h)
          d += (h**2 + dy**2)**0.5
      return d
#+END_SRC
* TODO Vektorji v ravnini in prostoru
** TODO Vektorji
*** TODO Python razred za vektorje
Razširi razred ~Vektor~, ki predstavlja vektorje kot $n$-terica števil z
naslednjimi metodami 
- ~__add__~
- ~__sub__~
- ~__mul__~
- ~__rmul__~
ki predstavljajo osnovne operacije med vektorji.
#+name: Vektor
#+BEGIN_SRC python
  class Vektor:
      def __init__(self, *vred):
          if len(vred)==1 and hasattr(vred,'__getitem__'):
              self.vrednosti = tuple(vred[0])
          else:
              self.vrednosti = tuple(vred)
      def __getitem__(self, k):
          return self.vrednosti[k]
      def __setitem__(self, k, vrednost):
          self.vrednosti[k] = vrednost
      def __iter__(self):
          return self.vrednosti.__iter__()
      def __len__(self):
          return len(self.vrednosti)
      def __str__(self):
          return str(self.vrednosti)
#+END_SRC

Primer

#+BEGIN_SRC python :results output
<<Vektor>>
<<Vektor_osnove>>
a = Vektor(1,2,3)
b = Vektor(3,2,1)
print(a+b, a-b, 2*a,b*0.5)
#+END_SRC

#+RESULTS:
: (4, 4, 4) (-2, 0, 2) (2, 4, 6) (1.5, 1.0, 0.5)

**** Rešitev
#+name: Vektor_osnove
#+BEGIN_SRC python
  def __add__(self,b):
      return Vektor(ai + bi for ai,bi in zip(self,b))
  def __sub__(self,b):
      return Vektor(ai - bi for ai,bi in zip(self,b))
  def __mul__(self,alfa):
      return Vektor(alfa*ai for ai in self)
  def __rmul__(self,alfa):
      return self.__mul__(alfa)

  setattr(Vektor, '__add__', __add__)
  setattr(Vektor, '__rmul__', __rmul__)
  setattr(Vektor, '__sub__', __sub__)
  setattr(Vektor, '__mul__', __mul__)
#+END_SRC
*** TODO Skalarni in vektorski produkt
Definiraj funkciji ~dot(a,b)~ in ~cross(a,b)~, ki izračuna skalarni in vektorski
produkt vektorjev ~a~ in ~b~.
#+name: dot_cross¸
#+BEGIN_SRC python
  def dot(a,b):
      return sum(ai*bi for ai, bi in zip(a,b))
  def cross(a,b):
      return Vektor(a[1]*b[2]-a[2]*b[1],
                    a[2]*b[0]-a[0]*b[2],
                    a[0]*b[1]-a[1]*b[0])

#+END_SRC

#+RESULTS:
: None

*** TODO Enakost, kolinearnost in koplanarnost vektorjev
 Npiši funkcijo ~kolinearna(a,b)~, ki preveri ali sta dva vektorja ~a~ in ~b~
 kolinearna in vrne ~True~, če sta kolinearna in ~False~, če nista.
 Vektorja ~a~ in ~b~ sta bodisi seznama tipa ~list~ ali n-terici tipa ~tuple~.
 
 Na primer:
#+BEGIN_SRC python :session kolinearna :results output :exports both
kolinearna([3,2], [6,4]), kolinearna((0,0,1), (1,0,0))
#+END_SRC

#+RESULTS:
: (True, False)
**** Rešitev
#+name: kolinearna
#+BEGIN_SRC python :session kolinearna
  def kolinearna(a, b):
      n, m = len(a), len(b)
      if n != m:
          # vektorja nista enakih dimenzij
          return False
      for i in range(n):
          if a[i] !=0:
              # we have found the pivot
              k = b[i]/a[i]
              prvi, drugi = a, b
              break
          elif b[i] != 0:
              k = a[i]/b[i]
              prvi, drugi = b,a
              break
      for j in range(i+1,n):
          if k*prvi[j] != drugi[j]:
              return False
      return True
#+END_SRC

#+RESULTS: kolinearna

**** Testi
Check.part()
Check.equal('kolinearna([1,2,3], [2,4,6])', True)
Check.equal('kolinearna([0,0,0,0], [1,2,3,4])', True)
Check.equal('kolinearna([1,0], [1,0,0])', False)
Check.secret(kolinearna([0,0,1],[0,0,2]))
Check.secret(kolinearna([1,2],[-1,-2]))
Check.secret(kolinearna([0,0,1],[0,1,-2]))
*** TODO Koplanarni vektorji 
Npiši funkcijo ~koplanarni(a,b,c)~, ki preveri ali trije 3D vektorji ~a~, ~b~ in ~c~
ležijo na isti ravnini in vrne ~True~, če ležijo in ~False~ sicer.
Vektorji ~a~, ~b~ in ~c~ so bodisi seznama tipa ~list~ ali n-terici tipa ~tuple~.

Na primer:

#+BEGIN_SRC python :results output :exports both
print(koplanarni([3,2,0], [6,4,0],[-1,2,0]))
print(koplanarni((1,0,0), (0,1,0),(0,0,1)))
#+END_SRC
**** Rešitev
#+name: koplanarni
#+BEGIN_SRC python

def dot(x,y):
    "Izračuna skalarni produkt dveh vektorjev"
    return sum(x[i]*y[i] for i in range(len(x)))
def cross(x,y):
    "Izračuna vektorski produkt dveh vektorjev"
    return (x[1]*y[2]-x[2]*y[1], x[2]*y[0]-x[0]*y[2], x[0]*y[1]-x[1]*y[0])

def koplanarni(a, b, c):
    # pri koplanarnih vektorjih je mešani produkt enak 0
    return dot(a,cross(b,c)) == 0
#+END_SRC
**** Testi
Check.part()
Check.equal('koplanarni([1,2,0], [2,4,0],[-2,3,0])', True)
Check.equal('koplanarni([1,0,0], [0,1,0],[0,0,1])', False)
Check.equal('koplanarni([1,2,2], [0,1,2],[0,0,1])', False)
Check.equal('koplanarni([1,0,-3], [0,1,0],[1,1,-3])', True)
Check.equal('koplanarni([1,2,3], [0,1,2],[0,0,0])', True)
Check.equal('koplanarni([0,1,0], [0,1,2],[1,0,1])', False)
Check.secret(koplanarni([1,1,2], [2,1,2],[1,2,1]))
Check.secret(koplanarni([1,2,1], [1,1,1],[1,3,1]))
Check.secret(koplanarni([2,2,2], [1,-2,1],[1,1,1]))
Check.secret(koplanarni([1,1,0], [0,1,2],[1,-1,1]))
*** TODO Linearna odvisnost
Napiši funkcijo ~odvisni(*vektorji)~, ki preveri ali so dani vektorji
linearno odvisni in vrne ~True~, če so odvisni in ~False~, če niso.
Vektorji so lahko poljubne dimenzije. Uporabiš
lahko metodo ~linalg.matrix_rank~ iz knjižnice ~numpy~.

Na primer:

#+BEGIN_SRC python
    >>> odvisni([1,1],[1,2],[3,4])
    True
    >>> odvisni([1,2,3],[1,2,4])
    False
#+END_SRC
**** Rešitev
#+name: odvisni
#+BEGIN_SRC python
import numpy as np
def odvisni(*vektorji):
    matrika = np.array(vektorji)
    return np.linalg.matrix_rank(matrika)<len(vektorji)
#+END_SRC
**** Testi

#+BEGIN_SRC python
Check.part()
Check.equal('odvisni(list(range(10)),10*[1])', False)
Check.equal('odvisni(3*[1],3*[2],3*[0])', True)
Check.equal('odvisni([1,0,0],[0,1,1],[0,1,-1])', False)
Check.secret(odvisni([1,1,1],[1,2,3],[0,0,0]))
Check.secret(odvisni([1,1,1],[1,1,2],[0,1,0]))
#+END_SRC

** TODO Premica in ravnina v 3D
*** TODO Razred za ravnino v prostoru
Sestavite razred ~Ravnina~, ki predstavlja ravnino v prostoru.
Razred naj ima metodo ~__init__(self,n,T)~, ki ravnino določi z normalo in točko
in metodo ~vsebuje(self,T)~, ki preveri ali točka ~T~ leži na ravnini.
Na primer:

#+BEGIN_SRC python 
R = Ravnina([1,1,1],[0,0,0]) # ravnina x+y+z=0
R.vsebuje([1,0,-1])
#+END_SRC

Dopolnite razred ~Ravnina~ z metodo ~__eq__(self,other)~, ki preveri
ali objekta ~self~ in ~other~ predstavljata isto ravnino.

Na primer:

    >>> Ravnina([1,1,1],[0,0,0]) == Ravnina([-1,-1,-1],[1,0,-1])
    True

**** Rešitev

#+name: ravnina
#+BEGIN_SRC python
from numpy import dot
class Ravnina:
    def __init__(self,n,T):
        self.n = n # koeficientni a b c
        self.d = dot(n,T) # koeficient d
        self.T = T #
    def vsebuje(self,T):
        return dot(self.n,T) == self.d
    def __eq__(self,other):
        a,b,c,d = self.n+[self.d]
        e,f,g,h = other.n+[other.d]
        # preverimo, če sta vektorja koeficientov kolinearna (ne najbolj optimalno)
        return a*f == b*e and a*g==c*e and b*g==c*f and a*h==d*e and b*h==d*f and c*h==d*g
#+END_SRC
**** Testi

#+BEGIN_SRC python
Check.part()
Check.equal('Ravnina([1,2,3],[1,0,0]).vsebuje([0,-1,1])', True)
Check.equal('Ravnina([1,2,3],[1,0,0]).vsebuje([0,1,1])', False)
Check.secret('Ravnina([1,2,3],[1,2,3]).vsebuje([0,1,1])')
Check.secret('Ravnina([1,2,3],[1,2,3]).vsebuje([14,0,0])')

Check.part()
Check.equal('Ravnina([1,2,3],[1,0,0])==Ravnina([1,2,3],[0,-1,1])', True)
Check.equal('Ravnina([1,2,3],[1,0,0])==Ravnina([2,4,6],[1,0,1])', False)
Check.equal('Ravnina([1,2,3],[1,0,0])==Ravnina([2,4,6],[1,0,0])', True)
Check.secret('Ravnina([1,2,3],[1,2,3])==Ravnina([1,2,3],[1,2,-3])')
Check.secret('Ravnina([1,2,3],[1,2,3])==Ravnina([3,6,9],[14,0,0])')
Check.secret('Ravnina([0,0,3],[1,2,3])==Ravnina([1,2,3],[14,0,0])')
Check.secret('Ravnina([0,2,0],[1,2,3])==Ravnina([0,1,0],[1,2,3])')
#+END_SRC
*** TODO Razred za premico v prostoru
Sestavite razred ~Premica~, ki predstavlja premico v prostoru.
Razred naj ima metodo ~__init__(self,e,T)~, ki premico določi
s smernim vektorjem ~e~ in točko ~T~. Razred naj ima tudi metodo ~skozi_tocke(A,B)~, ki naj vrne premico skozi točki ~A~ in ~B~ in metodo
~__eq__(self,p)~, ki preveri ali sta dve premici enaki.

Na primer:
#+BEGIN_SRC python

    >>> p = Premica([1,2,3],[0,1,2]) # premica x=t,y=1+2t,z=2+3t
    >>> q = Premica.skozi_tocke([0,1,2],[1,3,5])
    >>> p == q
    True
#+END_SRC
**** Rešitev

#+name: premica
#+BEGIN_SRC python
from numpy import dot
class Premica:
    def __init__(self,e,T0):
        self.e = e # koeficientni a b c
        self.T0 = T0 # točka na premici
    def skozi_tocke(A,B):
        e = [B[i]-A[i] for i in range(len(A))] # e=B-A
        return Premica(e,A)
    def __eq__(self,other):
        # preverimo, če sta smerna vektorja koeficientov kolinearna in
        # če je vektor med dvema točkama na premicah tudi
        # vzporeden s smernima vektorjema
        a,b,c = self.e
        d,e,f = other.e
        T0T = [self.T0[i]-other.T0[i] for i in range(3)] # razlika
        r,s,t = T0T
        return a*s == b*r and a*t==c*r and b*t==c*s and a*e == b*d and a*f==c*d and b*f==c*e
#+END_SRC
**** Testi
#+BEGIN_SRC python

Check.part()
Check.equal('Premica([1,2,3],[1,0,0])==Premica([-1,-2,-3],[0,-2,-3])', True)
Check.equal('Premica([1,2,0],[1,0,0])==Premica([2,4,0],[2,2,0])', True)
Check.equal('Premica([1,2,0],[1,0,0])==Premica([2,4,0],[2,1,0])', False)
Check.equal('Premica([1,2,0],[1,0,0])==Premica.skozi_tocke([1,0,0],[2,2,0])', True)
Check.equal('Premica.skozi_tocke([1,1,1],[3,5,1])==Premica([2,4,0],[2,1,0])', False)
Check.secret('Premica([1,2,3],[1,2,3])==Premica([1,2,3],[1,2,-3])')
Check.secret('Premica([1,2,3],[1,2,3])==Premica([1,2,3],[0,0,0])')
#+END_SRC
#+END_SRC
*** TODO Presečišče premice in ravnine
Napišite funkcijo ~presecisce(p,R)~, ki izračuna presečišče
premice ~p~ in ravnine ~R~. če presečišča ni
ali jih je neskončno naj funkcija javi napako tipa
~Exception('Presečišča ni ali jih je neskončno')~. 
Argument ~p~ naj bo razreda ~Premica~, ~R~ pa razreda ~Ravnina~.

Na primer:

#+BEGIN_SRC python
    >>> presecisce(Premica([1,2,3],[1,2,3]), Ravnina([1,1,1],[1,2,3]))
    [1,2,3]
    >>> presecisce(Premica([1,0,-1],[0,0,1]), Ravnina([1,1,1],[0,0,2]))
    None
#+END_SRC

**** Rešitev
#+name: presecisce
#+BEGIN_SRC python

from numpy import dot
from numpy.linalg import solve
class Ravnina:
    def __init__(self,n,T):
        self.n = n # koeficientni a b c
        self.d = dot(n,T) # koeficient d
    def vsebuje(self,T):
        return dot(self.n,T) == self.d

class Premica:
    def __init__(self,e,T0):
        self.e = e # koeficientni a b c
        self.T0 = T0 # točka na premici
    def skozi_tocke(A,B):
        e = [B[i]-A[i] for i in range(len(A))] # e=B-A
        return Premica(e,A)

def presecisce(p,R):
    if dot(p.e,R.n)==0:
        raise Exception('Nič ali neskončno presečišč!')
    t = (R.d-dot(R.n,p.T0))/dot(R.n,p.e)
    return [p.T0[i]+t*p.e[i] for i in range(3)]

#+END_SRC

**** Testi

#+BEGIN_SRC python
Check.part()
Check.equal('presecisce(Premica([1,2,3],[0,-2,-3]),Ravnina([-1,-2,-3],[0,-2,-3]))', [0,-2,-3])
try:
    koda = 'presecisce(Premica([1,2,0],[1,0,0]),Ravnina([2,-1,0],[2,2,0]))'
    eval(koda)
    Check.error('%s bi moralo javiti napako.'%koda)
except Exception as ex:
    errmsg = "Nič ali neskončno presečišč!"
    if ex.args[0] != errmsg:
        Check.error("Če je presečišč neskončno ali nobenega, mora funkcija javiti napako z Exception('%s')" % errmsg)
Check.equal('presecisce(Premica([1,2,3],[1,0,0]),Ravnina([-1,-2,-3],[-4,0,-3]))', [0,-2,-3])
Check.equal('presecisce(Premica.skozi_tocke([1,1,1],[0,2,2]),Ravnina([-1,0,1],[0,2,1]))',[0.5,1.5,1.5])
for i in range(10):
  Check.secret('presecisce(Premica([1,2+i,3],[0,1,i]),Ravnina([-1+i,-2,-3],[0,-2,-3]))')
Check.secret('presecisce(Premica.skozi_tocke([1,2,3],[0,2,1]),Ravnina([-1,-2,-3],[0,-2,-3]))')
#+END_SRC

** TODO Raytracing: krogla in točkasto svetilo
Pri tej nalogi bomo generirali sliko krogle osvetljene z enim točkastim svetilom 
v praznem prostoru.
*** TODO Presečišče poltraka in ravnine
Napiši funkcijo ~presecisce(poltrak, krogla)~, ki izračuna prvo presečišče
poltraka in krogle oziroma vrne ~None~, če presečišča ni. Poltrak naj bo podan
kot par trojic ~(T0,e)~, kjer je ~T0~ začetna točka poltraka, ~e~ pa smerni
vektor. Krogla naj bo tudi par  ~(S,r)~, kjer je ~S~ trojica koordinat središča
krogle in ~r~ polmer. Če je izhodišče poltraka znotraj krogle, naj funkcija vrne
~None~. 

Primer:

#+BEGIN_SRC python
    >>> presecisce(((0,0,0),(1,0,0)), ((2,0,0),1))
    (1,0,0)
    >>> presecisce(((0,0,0),(-1,0,0)), ((2,0,0),1)) # vrne None
    >>> presecisce((0,0,0),(1,0,0)), ((0,0,0),1)) # vrne None
#+END_SRC

**** Rešitev
#+BEGIN_SRC python

def dot(x,y):
    return sum(x[i]*y[i] for i in range(len(x)))

def presecisce(poltrak, krogla):
    T0, e = poltrak
    S, r = krogla
    # vektorska enacba krogle (rT - rS).(rT - rS)=r
    # rT.rT - 2rT.rS + rS.rS - r = 0
    # enacba poltraka rT = rT0 + t*e
    # presecisce doloca kvadratna enacba
    # (rT0 + t*e).(rT0 + t*e) - 2(rT0 + t*e).rS + rS.rS - r = 0
    # e.e*t^2 + 2*rT0.e*t + rT0.rT0 -2*rT0.rS - 2*e.rS*t + rS.rS - r = 0
    a = dot(e,e)
    b = 2*(dot(e,T0)-dot(e,S))
    c = dot(T0,T0) - 2*dot(T0,S) + dot(S,S) - r*r
    D = b**2 - 4*a*c
    if D<0:
        return None
    t = (-b-D**0.5)/(2*a)
    if t<0:
        return None
    else:
        return tuple(T0[i]+t*e[i] for i in range(len(T0)))

#+END_SRC
Check.part()
Check.equal('presecisce(((0,0,0),(1,0,0)), ((2,0,0),1))', (1,0,0))
Check.equal('presecisce(((0,0,0),(-1,0,0)), ((2,0,0),1.5))', None)
Check.equal('presecisce(((0,0,0),(1,0,0)), ((0,0,0),2))', None)
Check.secret(presecisce(((1,1,1),(1,1,1)),((2,0,0),1)))
Check.secret(presecisce(((1,2,-1),(-1,2,2)),((2,3,1),3)))
Check.secret(presecisce(((1,0,1),(1,2,1)),((2,1,-1),2)))
Check.secret(presecisce(((1,0,1),(1,2,2)),((5,10,0),6)))

*** TODO Osvetljenost
Napiši funkcijo ~osvetljenost(T, krogla, svetilo)~, ki določi osvetljenost točke ~T~ na obodu krogle ~krogla=(S,r)~,
če kroglo osvetlimo s svetilom v točki ~S~. Osvetljenost izračunamo s formulo
$$\frac{\cos{\alpha}}{r^2},$$
kjer je $r$ razdalja med točko na krogli in svetilom, kot $\alpha$ pa je kot med normalo na kroglo dani točki in vpadnim žarkom (daljico,
ki točko $T$ povezuje s svetilom).
Če je kot $\alpha$ večji kot $\pi/2$, naj funkcija vrne $0$.
Primer:

    >>> osvetljenost((1,0,0),((2,0,0),1), (0,0,0))
    1
    >>> osvetljenost((1,0,0),((2,0,0),1),(4,0,0))
    0
    >>> osvetljenost((1,0,0),((2,0,0),1),(0,3**0.5,0))
    0.125

**** Rešitev
#+BEGIN_SRC python

def dot(x,y):
    return sum(x[i]*y[i] for i in range(len(x)))

def osvetljenost(T, krogla, svetilo):
    S, r = krogla
    L = svetilo
    n = tuple(T[i]-S[i] for i in range(len(S)))
    TL = tuple(L[i]-T[i] for i in range(len(T)))
    return max(0, dot(n,TL)/dot(n,n)**0.5/dot(TL,TL)**1.5)

#+END_SRC
Check.part()
Check.equal('osvetljenost((1,0,0),((2,0,0),1), (0,0,0))', 1)
Check.equal('osvetljenost((1,0,0),((2,0,0),1),(4,0,0))', 0)
Check.equal('osvetljenost((1,0,0),((2,0,0),1),(0,3**0.5,0))', 0.125)
Check.secret(osvetljenost((1,0,0),((2,0,0),1),(1,3**0.5,0)))
Check.secret(osvetljenost((0,0,0),((2,0,0),2),(-1,3,0)))

*** TODO Krogla osvetljena s točkastim svetilom 
Napiši funkcijo ~pogled(kamera,okvir, krogla, svetilo, slika)~, ki izdela sliko (~slika~ tipa ~PIL.Image~) ~krogle~ osvetljene s ~svetilom~,
ki jo naredi ~kamera~ skozi dani ~okvir~.

Parametri:

- ~kamera~: trojica koordinat položaja kamere v prostoru
- ~okvir~: par ~(A,u,v)~, kjer je ~A~ oglišče, ~u~ in ~v~ pa vektorja stranic paralelograma $ABCD$
- ~krogla~: par ~((xs,ys,zs),r)~
- ~svetilo~: par ~((xl,yl,zl),P)~, kjer je prva trojica predstavlja koordinate svetila, ~P~ pa je število, sorazmerno moči svetila.
- ~slika~ : objekt tipa ~PIL.Image~, ki ga dobimo z ukazom ~PIL.Image('F',(n,m),"black")~

Vrednost piksla z indeksi $(i,j)$ na sliki, naj bo enaka osvetljenosti
$$\frac{P\cos\alpha}{r^2}$$
točke na krogli, ki jo zadane žarek iz kamere skozi točko v okvirju
$$\vec{r}_T=\vec{r}_{A}+\frac{i}{n}\vec{u}+\frac{m-j}{m}\vec{v}.$$

Primer:

#+BEGIN_SRC python
    >>>from PIL import Image
    >>>slika = Image.new('F',(255,255),"black")
    >>>kamera = (0,0,0); okvir = ((1,-1,-1),(0,2,0),(0,0,2));
    >>>krogla = ((2,0,0),1); svetilo = ((0,-3,0),500);
    >>>pogled(kamera, okvir, krogla, svetilo, slika)
    >>>slika.show()
#+END_SRC

Prikaže sliko
#+BEGIN_EXPORT html
<img alt="Slika krogle" src="data:image/png;base64,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">
      #+END_EXPORT

#+BEGIN_SRC python
    >>> slika.getpixel((100,100))
    85.13904571533203
#+END_SRC
#+BEGIN_SRC python

def dot(x,y):
    return sum(x[i]*y[i] for i in range(len(x)))
def plus(x,y):
    return [x[i]+y[i] for i in range(len(x))]
def minus(x,y):
    return [x[i]-y[i] for i in range(len(x))]
def mul(alfa,x):
    return [alfa*x[i] for i in range(len(x))]

def osvetljenost(T, krogla, svetilo):
    S, r = krogla
    L = svetilo
    n = tuple(T[i]-S[i] for i in range(len(S)))
    TL = tuple(L[i]-T[i] for i in range(len(T)))
    return max(0, dot(n,TL)/dot(n,n)**0.5/dot(TL,TL)**1.5)

def presecisce(poltrak, krogla):
    T0, e = poltrak
    S, r = krogla
    # vektorska enacba krogle (rT - rS).(rT - rS)=r
    # rT.rT - 2rT.rS + rS.rS - r = 0
    # enacba poltraka rT = rT0 + t*e
    # presecisce doloca kvadratna enacba
    # (rT0 + t*e).(rT0 + t*e) - 2(rT0 + t*e).rS + rS.rS - r = 0
    # e.e*t^2 + 2*rT0.e*t + rT0.rT0 -2*rT0.rS - 2*e.rS*t + rS.rS - r = 0
    a = dot(e,e)
    b = 2*(dot(e,T0)-dot(e,S))
    c = dot(T0,T0) - 2*dot(T0,S) + dot(S,S) - r*r
    D = b**2 - 4*a*c
    if D<0:
        return None
    t = (-b-D**0.5)/(2*a)
    if t<0:
        return None
    else:
        return tuple(T0[i]+t*e[i] for i in range(len(T0)))

def pogled(camera, okvir, krogla, svetilo, slika):
    n, m = slika.size
    cv, u, v = okvir
    bc, r = krogla
    light, W = svetilo
    pixels = slika.load()
    for i in range(n):
        xvi = plus(cv, mul(i/n,u)) # xvi = cv + i*dx
        for j in range(m):
            xvij = plus(xvi, mul((m-j)/m,v)) # xvij = xvi + j*dy
            e_ray = minus(xvij, camera) # e_ray = xvij - camera
            # (x-bc)(x-bc)-r=0 => x.x -2x.bc + bc.bc - r = 0
            # x = camera + t*e_ray
            # x.x = camera.camera + 2*t*e_ray.camera + t**2*e_ray.e_ray
            # x.bc = camera.bc + t*e_ray.bc
            a = dot(e_ray,e_ray)
            b = 2*dot(e_ray,camera) - 2*dot(e_ray,bc)
            c = dot(camera,camera) - 2*dot(camera,bc) + dot(bc,bc) - r
            D = b**2 - 4*a*c
            if D<0:
                continue
            t1 = (-b - D**0.5)/(2*a)
            t2 = (-b + D**0.5)/(2*a)
            if t1 >= 1:
                t = t1
            elif t2 >= 1:
                t = t2
            else:
                continue
            P = plus(camera, mul(t,e_ray))
            lv = minus(light, P)
            norm = minus(P, bc)
            if dot(norm,lv)<=0:
                continue
            cos = W*dot(norm,lv)/a**0.5/dot(norm,norm)**0.5/dot(lv,lv) # cosine/r^2
            pixels[i,j] = cos
    return slika

#+END_SRC

**** Testi 
#+BEGIN_SRC python

Check.part()
from PIL import Image
slika = Image.new('F',(255,255),"black")
kamera = (0,0,0); okvir = ((1,-1,-1),(0,2,0),(0,0,2)); krogla = ((2,0,0),1); svetilo = ((0,-3,0),500);
pogled(kamera, okvir, krogla, svetilo, slika)
slika.show()
pixels = slika.load()
#print(pixels[100,100])
# generiramo sliko za tekst
#import base64
#from io import BytesIO
#buf = BytesIO()
#slika.convert(mode='L').save(buf, format="PNG")
#print("<img alt=\"Slika krogle\" src=\"data:image/png;base64,%s\">"%base64.b64encode(buf.getvalue()))

Check.equal('slika.getpixel((0,0))', 0)
Check.equal('slika.getpixel((100,100))', 85.13904571533203)
Check.secret(slika.getpixel((100,125)))

#+END_SRC

** TODO Raytracing: tetraeder in točkasto svetilo

Na Khan academy Pixar [[https://www.khanacademy.org/partner-content/pixar/rendering][prikazuje]], kako delajo risane filme.
Pomemben del procesa, ki pripelje do končnega izdelka je tudi metoda 
„sledenja žarkom“(angl. raytracing), ki omogoča verno poustvarjanje osvetlitve.
Ta naloga ilustrira, kako deluje „raytracing“.

*** TODO Presečišče poltraka in ravnine

Definiraj funkcijo ~presek(p, R)~ ki vrne presečišče poltraka ~p~ in ravnine ~R~.
Če presečišča ni, naj funkcija vrne ~None~. Poltrak je podan kot par dveh točk (trojice števil),
kjer je prva točka začetna točka poltraka, druga pa poljubna točka na poltraku. Npr. poltrak
~p=((0,0,0),(1,0,0))~ predstavlja pozitivni del osi $x$.
Ravnina je podana s koeficienti enačbe $ax+by+cz=d$ kot četvorka števil ~R=(a,b,c,d)~(tuple).

Primer:

#+BEGIN_SRC python

    >>> presek(((0,0,2),(0,0,1)), (1,1,1,0))
    (0,0,0)
    >>> presek(((0,0,1),(0,0,2)), (1,1,1,0)) #vrne None
    >>>

#+END_SRC

**** Rešitev
#+BEGIN_SRC python

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))

def presek(p, R):
    T0,T = p
    e = tuple(T[i]-T0[i] for i in range(len(T))) # smerni vektor poltraka
    n = R[0:3] # normala ravnine
    # enačbo poltraka x = T0 + t*e vstavimo v enačbo ravnine n.x=d
    # in dobimo enačbo n.(T0 + t*e)=d iz katere izrazimo t
    # t = (d - n.T0)/(n.e)
    a = dot(n,e)
    if a==0:
        return None # p in R vzporedni
    t = (R[3]-dot(n,T0))/a
    if t<0:
        return None
    else:
        return tuple(T0[i]+t*e[i] for i in range(len(T0)))

#+END_SRC

**** Testi

#+BEGIN_SRC python

Check.part()
Check.equal('presek(((0,0,2),(0,0,1)),(1,1,1,0))', (0,0,0))
Check.equal('presek(((0,0,1),(0,0,2)),(1,1,1,0))', None)
Check.equal('presek(((1,1,1),(2,2,2)),(1,-1,0,2))',None)
Check.secret(presek(((1,1,1),(1,2,2)),(1,2,3,4)))
Check.secret(presek(((1,2,2),(1,1,1)),(3,2,1,-4)))
Check.secret(presek(((1,0,2),(1,1,1)),(0,2,1,1)))
Check.secret(presek(((1,2,2),(1,1,1)),(3,2,0,2)))
Check.secret(presek(((1,2,0),(1,1,0)),(3,0,1,-4)))

#+END_SRC

*** TODO Na kateri strani ravnine leži točka?

Definiraj funkcijo ~stran(T,R)~, ki pove na kateri strani ravnine ~R~ leži točka ~T~. 
Funkcija naj vrne ~1~, če točka leži nad ravnino (glede na smer normale), ~-1~, če točka leži pod ravnino
in ~0~, če je točka na ravnini. 
Točka je podana kot trojica (tuple) števil ~T=(0,0,0)~,
ravnina pa s koeficienti enačbe $ax+by+cz=d$ kot četvorka števil ~R=(a,b,c,d)~(tuple).
#### Primer:

    >>> stran((0,0,1), (0,0,1,0))
    1
    >>> stran((0,0,-1), (0,0,1,0))
    -1
    >>> stran((0,0,0),(0,0,1,0))
    0

**** Rešitev
#+BEGIN_SRC python

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))

def stran(T, R):
    n = R[0:3] # normala ravnine
    # stran nam pove predznak izraza ax+by+cz-d
    s = dot(n,T)-R[3]
    if s==0:
        return 0 # T leži na R
    elif s>0:
        return 1
    else:
        return -1

#+END_SRC

**** Točke
#+BEGIN_SRC python

Check.part()
Check.equal('stran((0,0,1),(0,0,1,0))', 1)
Check.equal('stran((0,0,-1),(0,0,1,0))', -1)
Check.equal('stran((0,0,2),(1,1,1,0))', 1)
Check.equal('stran((0,1,1),(-2,1,1,2))', 0)
Check.equal('stran((1,0,1),(2,2,1,4))', -1)
Check.secret(stran((2,-3,1),(2,2,1,3)))
Check.secret(stran((4,-3,1),(2,2,1,3)))
Check.secret(stran((2,-3,1),(2,-5,1,3)))
Check.secret(stran((0,-3,1),(-1,0,1,-3)))
Check.secret(stran((0.5,-3,1),(2,2,1,6)))

#+END_SRC

*** TODO Ali leži dana točka na trikotniku ABC?

Večina modelov teles v 3D je sestavljena iz majhnih trikotnikov(triangulirana),
zato mora program za raytracing vedeti, če svetlobni žarek zadene trikotnik in
ne le ravnino trikotnika. Točka $T$ leži v trikotniku $\triangle ABC$ natanko
tedaj, ko velja:  

 - točka $T$ leži na ravnini trikotnika
 - točki $C$ in $T$ ležita na isti strani ravnine, ki vsebuje $AB$ in je pravokotna na trikotnik
 - točki $A$ in $T$ ležita na isti strani ravnine, ki vsebuje $BC$ in je pravokotna na trikotnik
 - točki $B$ in $T$ ležita na isti strani ravnine, ki vsebuje $AC$ in je pravokotna na trikotnik

Definiraj funkcijo ~na_trikotniku(T,trikotnik)~, ki pove ali dana točka ~T~ leži
na danem trikotniku. Funkcija naj vrne ~true~ ali ~false~. Robovi in oglišča so
tudi del trikotnika.  

Točka je podana kot trojica (tuple) števil ~T = (0,0,0)~,
trikotnik pa kot trojica točk ~trikotnik = ((1,2,3), (4,5,6), (3,2,1))~.

Primer
#+BEGIN_SRC python

    >>> na_trikotniku((1,1,0), ((0,0,0), (3,0,0), (0,3,0)))
    True
    >>> na_trikotniku((1,1,0), ((0,0,1), (3,0,1), (0,3,1))) # točka ne leži na ravnini trikotnika
    False
    >>> na_trikotniku((1,1,0), ((0,0,0), (2,0,0), (0,2,0))) # točka leži robu
    True
    >>> na_trikotniku((1,1,0), ((0,0,0), (1,0,0), (0,1,0))) # točka leži ravnini a ne znotraj trikotnika
    False

#+END_SRC
**** Rešitev
#+BEGIN_SRC python

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))
def cross(x,y):
    "Funkcija izračuna vektorski produkt dveh vektorjev"
    return (x[1]*y[2] - x[2]*y[1], x[2]*y[0] - x[0]*y[2], x[0]*y[1] - x[1]*y[0])

def na_trikotniku(T,ABC):
    A, B, C = ABC
    a = [B[i]-A[i] for i in range(len(A))]
    b = [C[i]-B[i] for i in range(len(B))]
    c = [A[i]-C[i] for i in range(len(C))]
    n = cross(a,b) # normala ravnine trikotnika
    d = dot(n,A) # desna stran enacbe
    if dot(T,n) != d:
        return False # ne leži na ravnini
    # ravnina, ki vsebuje AB in je pravokotna na trikotnik
    na = cross(n,a)
    da = dot(A,na)
    if (dot(T,na) - da)*(dot(C,na) - da) < 0:
        # T in C sta na nasprotnih straneh stranica AB
        return False
    # ravnina, ki vsebuje BC in je pravokotna na trikotnik
    nb = cross(n,b)
    db = dot(B,nb)
    if (dot(T,nb) - db)*(dot(A,nb) - db) < 0:
        # T in A sta na nasprotnih straneh BC
        return False
    # ravnina, ki vsebuje CA in je pravokotna na trikotnik
    nc = cross(n,c)
    dc = dot(C,nb)
    if (dot(T,nc) - dc)*(dot(B,nc) - dc) < 0:
        # T in B sta na nasprotnih straneh CA
        return False
    else:
        return True

#+END_SRC
Check.part()
Check.equal('na_trikotniku((1,1,0), ((0,0,0), (3,0,0), (0,3,0)))', True)
Check.equal('na_trikotniku((1,1,0), ((0,0,1), (3,0,1), (0,3,1)))', False)
Check.equal('na_trikotniku((1,1,0), ((0,0,0), (2,0,0), (0,2,0)))', True)
Check.equal('na_trikotniku((1,1,0), ((0,0,0), (1,0,0), (0,1,0)))', False)
Check.equal('na_trikotniku((1,1,1), ((3,0,0), (0,3,0), (0,0,3)))', True)
Check.equal('na_trikotniku((1,2,-1), ((3,0,0), (0,3,0), (0,0,3)))', False)
Check.secret(na_trikotniku((1,2,3), ((0,1,3), (-1,0,3), (1,3,2))))
Check.secret(na_trikotniku((1,1,0), ((0,0,0), (3,0,0), (0,3,0))))
Check.secret(na_trikotniku((1,1,2), ((1,2,-3), (3,-3,-1), (2,3,3))))
Check.secret(na_trikotniku((1,1,-2), ((0,0,0), (3,1,-1), (1,3,5))))
Check.secret(na_trikotniku((1,-2,0), ((0,0,0), (3,1,2), (0,3,1))))
Check.secret(na_trikotniku((0,0,0), ((1,-1,0), (3,-2,-1), (-2,3,-1))))
Check.secret(na_trikotniku((1,1,2), ((0,0,0), (3,0,0), (0,3,0))))
Check.secret(na_trikotniku((1,1,0.5), ((0,0,1.5), (3,0,0), (0,3,0))))
*** TODO Kam se odbije žarek

Definiraj funkcijo ~odboj(p, R)~, ki pove, kam se odbije svetlobni žarek, ki ga predstavlja poltrak ~p~, ko vpade na ravnino ~R~.

Funkcija naj vrne par ~(T,e)~, kjer je ~T~ začetna točka odbitega žarka in ~e~ smerni vektor, ki kaže v smeri odbitega žarka in
je enake dolžine kot ~e0~.

Poltrak je podan kot par ~p = (T0,e0)~, kjer je ~T0~ začetna točka, ~e0~ pa smerni vektor.
Ravnina je podano kot četvorka koeficientov ~R = (a,b,c,d)~ enačbe ravnine $ax+by+cz=d$. Če
poltrak ne zadene ravnine, naj funkcija vrne ~None~.

Primer

#+BEGIN_SRC python

    >>> odboj(((0,0,1), (1,0,-1)), (0,0,1,0))
    ((1,0,0),(1,0,1))
    >>> odboj(((0,0,1), (-1,0,1)), (0,0,1,0)) # poltrak ne seka ravnine
    None

#+END_SRC
**** Rešitev
#+BEGIN_SRC python

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))

def odboj(p, R):
    T0, e0 = p
    n = R[0:3]
    d = R[3]
    # enacba poltraka rT = rT0 + t*e0
    # enacba ravnine n.(rT) = n.(rT0 + t*e0) = n.rT0 + t*(n.e0) = d
    # t = (d - n.rT0)/(n.e0)
    cos = dot(n,e0)
    if cos == 0:
        # poltrak in ravnina sta vzporedni
        return None
    t = (d - dot(n,T0))/cos
    if t<0:
        #poltrak ne seka ravnine
        return None
    # Presecisce poltraka in ravnine
    T = tuple(T0[i] + t*e0[i] for i in range(len(T0)))
    # odbojni smerni vektor je enak e0 - 2*proj_n(e0)
    proj = cos/dot(n,n)
    e = tuple(e0[i] - 2*proj*n[i] for i in range(len(n)))
    return (T,e)

#+END_SRC
#+BEGIN_SRC python

Check.part()
Check.equal('odboj(((0,0,1),(1,0,-1)), (0,0,1,0))', ((1,0,0),(1,0,1)))
Check.equal('odboj(((0,0,1),(-1,0,1)), (0,0,1,0))', None)
Check.secret(odboj(((0,1,1),(1,-1,0)), (1,1,1,0)))
Check.secret(odboj(((0,1,0),(1,-1,0)), (0,2,1,2)))
Check.secret(odboj(((2,1,0),(1,-1,5)), (0,3,1,-3)))
Check.secret(odboj(((1,0,-3),(1,1,4)), (0,4,1,-5)))
Check.secret(odboj(((0,1,3),(-1,-1,3)), (0,5,1,1)))
Check.secret(odboj(((0,1,1),(-2,-1,2)), (1,6,1,1)))

#+END_SRC
**** Ali točka leži na trikotniku?
*** TODO Večkratni odboji
* TODO Matrike in sistemi enačb
** TODO Matrike
*** TODO Python razred za matrike
** TODO Sistemi enačb
*** TODO Gaussova eliminacija
*** TODO Polinomska interpolacija
*** TODO Maksimum funkcije podane s tabelo
Napišite funkcijo ~maksimum(x,y)~, ki poišče približno vrednost 
* Licenca 
#+BEGIN_EXPORT html
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
<img alt="Creative Commons licenca" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
</a><br />
<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Matematika skozi Python</span>, 
avtorja <a xmlns:cc="http://creativecommons.org/ns#" href="https://mrcinv.github.io" property="cc:attributionName" rel="cc:attributionURL">Martin Vuk</a> 
je objavljena pod licenco <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Priznanje avtorstva-Deljenje pod enakimi pogoji 4.0 Mednarodna licenco</a>.
<br />Za dodatna dovoljenja, ki presegajo obseg te licence, kontaktirajte avtorja. 
#+END_EXPORT
