# #+SETUPFILE: org-html-themes/setup/theme-readtheorg-local.setup
#+SETUPFILE: org-bootstrap-document/setup.org
#+OPTIONS: ':nil *:t -:t ::t <:t H:4 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+OPTIONS: email:t f:t inline:t num:2 p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t title:t toc:t todo:nil |:t
#+TITLE: Matematika skozi Python
#+DATE: <2017-01-26 čet>
#+AUTHOR: Martin Vuk
#+EMAIL: martin.vuk@fri.uni-lj.si
#+LANGUAGE: sl
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.1.1 (Org mode 9.0.3)
#+PROPERTY: header-args  :results output :exports both :eval no-export 
#+PROPERTY: header-args  :noweb strip-export 
* DONE Uvod 
  CLOSED: [2017-11-26 ned 22:55]
Pred vami je priročnik, ki vam bo pomagal poglobiti in povezati znanje
programiranja in matematike. Nastal kot dopolnilno gradivo pri predmetu
Matematika za študente visokošolskega programa na Fakulteti za računalništvo in
informatiko Univerze v Ljubljani in je namenjen vsem, ki si pri tem predmetu
želijo naučiti malo več. Navezuje se na [[http://matematika.fri.uni-lj.si/mat/matvsp.pdf][učbenik]] in obsega naloge in primere s
področja zaporedij, funkcij, odvoda in integrala, vektorjev in matrik.

Naloge so rešene v programskem jeziku [[http://www.python.org][Python]], objavljene pa tudi na spletnem
portalu [[https://www.projekt-tomo.si/course/15/][projekt Tomo]], kjer lahko svoje rešitve tudi enostavno preskusite. V
pomoč pri reševanju nalog so na voljo tudi kratki videi na [[https://www.youtube.com/playlist?list=PLvmhvQsVlBOILqOi3rXooc016UlfcXC-T][YouTube kanalu
Matematika]]. Priročnik je na voljo v več formatih:

- [[file:index.html][HTML spletna stran]],
- [[file:index.pdf][PDF dokument]],
- predmet [[https://www.projekt-tomo.si/course/15/][Matematika]] na portalu [[https://www.projekt-tomo.si/][Projekt Tomo]] in
- [[http:index.org][izvorna koda]] v obliki  [[https://orgmode.org][Org-mode]] za urejevalnik [[https://www.gnu.org/software/emacs/][Emacs]].
 
** Kako uporabljati priročnik
Vsekakor najprej poskusite rešiti naloge povsem samostojno. Če se vam zatakne,
si poglejte splošna matematična navodila in poskusite vsaj programerski del
rešiti sami. Če tudi to ne gre, lahko pokukate v rešitev. Rešitve ne kopirajte,
ampak jo raje prepišite ali še bolje napišite sami. Tako boste imeli
več od tega.



* DONE Zaporedja in vrste
  CLOSED: [2017-11-27 pon 09:42]
V vsakdanjem življenju pojem zaporedja pomeni seznam elementov, pri katerem je
pomemben vrstni red. Na primer zaporedje plesnih korakov v koreografiji,
zaporedje not v glasbenem zapisu ali zaporedje postajališč na liniji mestnega
prometa. Ker pa matematike zanima vse, kar je povezano z neskončnostjo, si pod
pojmom zaporedja predstavljamo neskončna zaporedja. Formalno jih definiramo
kot funkcijo

$$\mathbb{N}\to A,$$ 

ki vsakemu naravnemu številu $n$
priredi nek element $a_n=a(n)$ iz množice $A$. Element $a_n$ imenujemo $n$ - ti
člen zaporedja.

V računalništvu si želimo, da se programi končajo, zato nas navadno zanimajo
le končna zaporedja. V Pythonu so končna zaporedja najpogosteje predstavljena s
podatkovnim tipom ~list~, ki je končen seznam elementov. Z zankami
~for~ in ~while~ se lahko sprehodimo po elementih seznama in izvedemo zaporedje
ukazov.

Kaj se zgodi, če vse člene zaporedja seštejemo? Dobimo *neskončno vrsto*.
Neskončna vrsta je namreč po definiciji formalna neskončna vsota členov
zaporedja. *Vsota neskončne vrste* je število, ki je enako limiti
delnih vsot prvih $n$ členov zaporedja, ko gre $n$ proti neskončnosti:
\[\sum_{n=0}^\infty a_n = \lim_{n\to\infty} \left(\sum_{k=0}^n a_k\right).\]   
** Zaporedje, podano s formulo
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: naloga
   :END:
Izpiši približne vrednosti prvih 15 členov zaporedja $a_n=\frac{n-1}{n+1}$,
začenši z $n=0$.
*** Namig
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
   Uporabi zanko ~for n in range(15):~.
*** Rešitev 
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
    #+BEGIN_SRC python :exports both :eval no-export 
      for n in range(15):
          print((n-1)/(n+1))
    #+END_SRC

    #+RESULTS:
    #+begin_example
    -1.0
    0.0
    0.3333333333333333
    0.5
    0.6
    0.6666666666666666
    0.7142857142857143
    0.75
    0.7777777777777778
    0.8
    0.8181818181818182
    0.8333333333333334
    0.8461538461538461
    0.8571428571428571
    0.8666666666666667
#+end_example
** Seznam členov zaporedja
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: naloga
   :END:
V spremenljivko ~a~ zapiši seznam (tipa ~list~) približnih vrednosti prvih 15 členov zaporedja
$a_n=\frac{n-1}{n+1}$ za $n\in 0,1,2\ldots$ Iz seznama izpiši člene $a_1$, $a_5$
in $a_{14}$.
*** Namig
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
   Uporabi zanko ~for n in range(15):~ in metodo ~append~.
*** Rešitev 
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
   #+BEGIN_SRC python :results output :exports both
     a = []
     for n in range(15):
         a.append((n-1)/(n+1))
     #izpišemo elemente seznama. Pazimo na to, da je prvi element seznama a[0].
     print("a_1 = %f, a_5 = %f, a_14 = %f" % (a[1], a[5], a[-1]))
   #+END_SRC

   #+RESULTS:
   : a_1=0.000000, a_5=0.666667, a_14=0.866667

** Rekurzivno zaporedje
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: naloga
   :END:
Zaporedje je podano z rekurzivno formulo $$a_{n+1}=\frac{2a_n^3+2}{3a_n^2}$$ in
začetnim členom $a_0=2$. Zapiši prvih 10 členov zaporedja. Kaj opaziš?
*** Namig
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
Nalogo lahko rešiš na dva načina: s ~for~ zanko ali z ~rekurzivno funkcijo~.
*** Rešitev
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
#+BEGIN_SRC python :results output :exports both :eval no-export
  an = 2
  print(an)
  for i in range(9):
      an = (2*an**3+2)/(3*an**2)
      print(an)
#+END_SRC

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example

Opazimo, da se členi zaporedja po 5. členu začnejo ponavljati. Tako zaporedje je
zato zelo verjetno *konvergentno*, zadnji izpisani členi pa so zelo dober približek
za *limito* zaporedja.
*** Rešitev z rekurzivno funkcijo
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
Zaporedje $a_n$ lahko definiramo tudi z *rekurzivno funkcijo*. Paziti moramo le,
da znotraj funkcije opravimo le en klic funkcije same nase, sicer časovna
zahtevnost eksponentno narašča z naraščajočim $n$.
#+BEGIN_SRC python :results output :exports both :eval no-export
  def clen(n):
      """Rekurzivna funkcija, ki vrne n-ti člen zaporedja, podanega z rekurzivno
      formulo a(n+1) = (2*a(n)^3 + 2)/(3*a(n)^2).
      """
      if n<=0:
          return 2
      else:
          an = clen(n-1)
          return (2*an**3 + 2)/(3*an**2)

  for n in range(10):
      print(clen(n))
#+END_SRC  

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example

Kljub temu da smo se z enim rekurzivnim klicem funkcije izognili eksponentni
časovni odvisnosti, je pri večkratnih klicih funkcije ~clen~ še vedno precej
izračunov, ki se vedno znova ponavljajo. Ob vsakem zaporednem klicu funkcije
namreč izračunamo vse člene od prvega do tistega, ki ga iščemo. Časovna
zahtevnost ~for~ zanke je tako kvadratična, medtem ko je pri prejšnji rešitvi
časovna zahtevnost linearna.
*** *Rešitev z neskončnim generatorjem
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
Za ilustracijo nalogo rešimo še z *generatorjem*. Generator je funkcija, ki je
posebne vrste *iteratorja*. *Iterator* je vsak objekt v Pythonu, ki pozna metodo ~next()~
in ga lahko uporabimo v ~for~ zanki. Funkcijo spremenimo v generator z uporabo
ukaza ~yield~, ki je zelo podoben ukazu ~return~, le da se ob njegovem klicu
izvajanje funkcije zamrzne do naslednjega klica metode ~next()~. Na ta način
lahko z generatorjem definiramo tudi neskončna zaporedja oziroma zaporedja,
katerih dolžin ne poznamo vnaprej.

Napisali bomo neskončen generator, zato moramo v zanki posebej poskrbeti, da se
le ta ustavi. To storimo tako, da s stavkom ~if~ preverimo, ali moramo izvajanje
zaključiti (z ukazom ~break~).

#+BEGIN_SRC python :results output :exports both :eval no-export
  def generator_clenov():
      "Generator za prvih n členov zaporedja an"
      an = 2
      while True:
          yield an
          an = (2*an**3+2)/(3*an**2)
  n = 0
  for clen in generator_clenov:
      print(clen)
      if n>9:
          break
      n += 1
#+END_SRC

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example
** Konvergenca zaporedja
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: naloga
   :END:
*Limita* zaporedja je število $a$ s posebno lastnostjo, da so vsi členi
zaporedja $a_m$ za $m>n$ poljubno blizu *limite*, če je le $n$ dovolj velik. 
Zaporedje je *konvergentno*, če ima limito. Bolj natančno: $a$ je limita
zaporedja $a_n$, če za vsak $\varepsilon>0$ obstaja $n$, tako da velja
\[a - \varepsilon < a_m < a + \varepsilon\] 
za vse indekse $m$, ki so večji od $n$.

Za zaporedje $$a_n=\frac{n^2+n-1}{1-2n^2}$$ poišči prvi člen $a_n$, ki se za
manj kot
$\varepsilon=0,01$ razlikuje od limite zaporedja $a_n$. Na ta način lahko
ugotovimo, kako „hitro“ dano zaporedje konvergira oziroma, pri katerem $n$ se
členi prvič približajo limiti na manj kot $\varepsilon$. 
*** Namig
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
Poišči najmanjše naravno število $n$, da bo $|a_n-a|<\varepsilon$, kjer je  
$$a=\lim_{n\to\infty}a_n=-\frac{1}{2}.$$ Uporabi zanko ~while~.
*** Rešitev
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
#+BEGIN_SRC python :results output :exports both :eval no-export
  n = 0
  a = -0.5
  eps = 0.01
  while abs((n**2+n-1)/(1-2*n**2)-a)>eps:
      n += 1
  print("n = %d" % n)
#+END_SRC

#+RESULTS:
: n = 50
*** *Rešitev z neskončnim generatorjem
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
Za ilustracijo nalogo rešimo še z generatorjem. 
#+BEGIN_SRC python :results output :exports both :eval no-export
  def generator_clenov():
      n = 0
      while True:
          yield n, (n**2+n-1)/(1-2*n**2)
          n += 1
  a = -0.5
  eps = 0.01

  for n, clen in generator_clenov():
      if abs(clen-a)<eps:
          print("n = %d" % n)
          break
#+END_SRC

#+RESULTS:
: n = 50

** Delne vsote vrste
   :PROPERTIES:
   :HTML_CONTAINER_CLASS: naloga
   :END:
Izpiši prvih 15 delnih vsot neskončne vrste 
$$\sum_{n=1}^\infty \frac{1}{2^n}.$$
Kaj se ti zdi, kateremu številu je enaka vsota neskončne vrste?

*** Namig
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
 V zanki ~for n in range(1,16):~ prištevaj člene zaporedja izbrani
 spremenljivki, ki jo pred zanko postaviš na 0.

*** Rešitev    
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: resitev
    :END:
#+BEGIN_SRC python :results output :exports both :eval no-export
  S = 0
  for n in range(1,16):
      S += 1/2**n
      print(S)
#+END_SRC

#+RESULTS:
#+begin_example
0.5
0.75
0.875
0.9375
0.96875
0.984375
0.9921875
0.99609375
0.998046875
0.9990234375
0.99951171875
0.999755859375
0.9998779296875
0.99993896484375
0.999969482421875
#+end_example

** Vsota vrste
Že v 17. stoletju sta James Gregory in Gottfried Leibniz uporabila vrsto
$$4\sum_{n=0}^\infty\left(-1\right)^n \frac{1}{1+2n}$$ za izračun števila $\pi$.
Vrsto sta izpeljala iz zapisa $\arctan(x)$ s potenčno vrsto. 

Napiši program (funkcijo) ~konvergenca~, ki za poljuben $\varepsilon > 0$ poišče
$n$, od katerega naprej so vse delne vsote za manj kot $\varepsilon$ oddaljene
od $\pi$ in tako pokaži, da vrsta res konvergira k $\pi$. 
Svoj program preskusi za $\varepsilon=10^{-4}$. 

Koliko pravilnih decimalk števila $\pi$ lahko tvoj program izračuna v manj 
kot 10 sekundah? Pri tem se moramo zavedati, da je čas izvajanja programa
odvisen od hitrosti in zasedenosti procesorja.

*** Namig
Uporabi zanko ~while~, v kateri preveri, ali je trenutna delna vsota za manj kot
$\varepsilon$ oddaljena od $\pi$. Čas lahko meriš s funkcijo ~time~ modula ~time~.

*** Rešitev

#+BEGIN_SRC python :results output :exports both :eval no-export
  import time
  from math import pi
  def konvergenca(epsilon):
      """Funkcija poišče najmanjši n, za katerega je n-ta delna vsota vrste s členi 
      4(-1)^n/(1+2n)
      za manj kot epsilon oddaljena od števila pi."""
      S = 0
      n = 0
      while abs(S-pi) > epsilon:
          S += (-1)**n*4/(1 + 2*n)
          n += 1
      return n-1
  zacetek = time.time()
  eps = 0.0001 
  n = konvergenca(eps)
  print("eps = {}, n = {} (v {} sekundah)".format(eps, n, time.time() - zacetek))
  # v manj kot 10 s lahko izračunamo 7 pravilnih decimalk števila pi.
  zacetek = time.time()
  eps =  0.00000005
  n = konvergenca(eps)
  print("eps = {}, n = {} (v {} sekundah)".format(eps, n, time.time() - zacetek))
#+END_SRC

#+RESULTS:
: eps = 0.0001, n = 9999 (v 0.010877370834350586 sekundah)
: eps = 5e-08, n = 19999991 (v 18.800929069519043 sekundah)

* Funkcije
Funkcija $f$ je predpis, ki vsakemu številu $x$ iz izbrane množice priredi določeno
število $f(x)$. Številu $x$, ki ga vstavimo v $f$, pravimo *argument*, številu
$f(x)$ pa *vrednost funkcije* $f$ pri argumentu $x$.

Tudi funkcije, kot jih poznamo v Pythonu, so neke vrste predpisi, ki za dane vhodne
argumente vrne določeno vrednost. Seveda pa funkcije v Pythonu lahko delajo
tudi druge stvari, npr. izpisujejo obvestila, shranjujejo rezultate v datoteke,
itd.

V tem poglavju bomo spoznali različne metode za iskanje ničel funkcij, hornerjev
algoritem za računanje vrednosti polinoma in postopek za računanje vrednosti
kotnih funkcij. 
** Ničle tabelirane funkcije
Ničla funkcije $f(x)$ je vrednost spremenljivke $x$, za katero
velja $f(x)=0$. 

Naj bo zvezna funkcija $f(x)$ znana le v nekaj diskretnih vrednostih $x$. Podana
imamo torej dva seznama enake dolžine ~x~ in ~y~, tako da velja ~y[i] == f(x[i])~.

Napiši funkcijo ~nicle(x,y)~, ki izračuna približne vrednosti ničel funkcije
$f(x)$, tako da funkcijo nadomesti z *linearnim zlepkom* in izračuna ničle
zlepka. Linearni zlepek dobimo tako, da graf funkcije $f(x)$ nadomestimo z
daljicami (linearno funkcijo $y=kx+n$) med točkami, ki so podane s seznamoma ~x~
in ~y~.

Funkcija ~nicle(x,y)~ naj vrne seznam približkov za ničle. Približki naj bodo
urejeni po velikosti. 

Primer vhodnih podatkov in klica funkcije:

#+BEGIN_SRC python :noweb strip-export :exports both :exports both
<<nicle>>
x = [-1, 0, 1, 2, 3]
y = [1, -1, 1, 2, 3]
x0 = nicle(x, y)
print(x0)
#+END_SRC

#+RESULTS:
: [-0.5, 0.5]
*** Matematična izpeljava
Označimo z $x_1,x_2,\ldots,x_n$ in z $y_1,y_2,\ldots, y_n$ vrednosti v tabelah
~x~ in ~y~. Za neznano zvezno funkcijo $f$ velja 
$$y_i=f(x_i).$$

Pri tem smo privzeli, da so vrednosti $x_i$ urejene po velikosti. Sicer jih
najprej uredimo. Ker je $f$ zvezna, lahko z gotovostjo trdimo, da je ničla na intervalu
$[x_i,x_{i+1}]$, če sta $y_i$ in $y_{i+1}$ različnega predznaka. Torej mora
funkcija ~nicle~ najprej poiskati intervale, kjer se to zgodi.

Denimo, da je na intervalu $[x_i,x_{i+1}]$ ničla. Enačbo za odsek linearnega
zlepka na tem intervalu dobimo tako, da poiščemo enačbo premice skozi točki na
krajiščih $(x_i,y_i)$ in $(x_{i+1},y_{i+1})$. V resnici nas zanima le, pri
kateri vrednosti, premica seka os $x$. To najlažje določimo s podobnimi
trikotniki:

#+header: :exports results :file zlepek.png 
#+header: :imagemagick yes :iminoptions -density 600 :imoutoptions -geometry 400 
#+header: :packages '(("" "tikz")) :border 1em :results raw
#+begin_src latex
  % Define block styles
  \usetikzlibrary{arrows}
\definecolor{uququq}{rgb}{0.25,0.25,0.25}
\definecolor{xdxdff}{rgb}{0.49,0.49,1}
\definecolor{qqqqff}{rgb}{0,0,1}
\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm]
\draw[->,color=black] (-1,0) -- (6,0);
\foreach \x in {-1,1,2,3,4,5}
\draw[shift={(\x,0)},color=black] (0pt,-2pt);
\draw[color=black] (5.64,0.09) node [anchor=south west] { x};
\draw[->,color=black] (0,-5) -- (0,3);
\foreach \y in {-5,-4,-3,-2,-1,1,2}
\draw[shift={(0,\y)},color=black] (2pt,0pt) -- (-2pt,0pt);
\draw[color=black] (0.11,2.57) node [anchor=west] { y};
\clip(-1,-5) rectangle (6,3);
\draw (1,2)-- (4,-4);
\draw (1,2)-- (1,0);
\draw (4,-4)-- (4,0);
\draw (1,0)-- (4,0);
%\begin{scriptsize}
\fill [color=qqqqff] (1,2) circle (1.5pt);
\draw[color=qqqqff] (1.75,2.28) node {$(x_i,y_i)$};
\fill [color=qqqqff] (4,-4) circle (1.5pt);
\draw[color=qqqqff] (5.1,-3.7) node {$(x_{i+1},y_{i+1}})$};
\fill [color=xdxdff] (1,0) circle (1.5pt);
\draw[color=xdxdff] (1.42,0.28) node {$x_i$};
\draw[color=black] (0.96,1.16) node {$y_i$};
\fill [color=qqqqff] (4,0) circle (1.5pt);
\draw[color=qqqqff] (4.78,0.28) node {$x_{i+1}$};
\draw[color=black] (5.05,-1.83) node {$y_{i+1}$};
\fill [color=uququq] (2,0) circle (1.5pt);
\draw[color=uququq] (2.32,0.28) node {$x$};
%\end{scriptsize}
\end{tikzpicture}
#+end_src

#+RESULTS:
[[file:zlepek.png]]
*** Test 
S testi preverimo pravilnost delovanja napisanih programov. Python ponuja
različne možnosti za pisanje testov. Za začetek bomo uporabili najpreprostejši
način, to je z uporabo ukaza ~assert~.

Napisano funkcijo najprej shranimo v datoteko, npr. ~nicle.py~. V datoteko
shranimo tudi testno kodo, npr. ~test_nicle.py~. Potem poženemo ~test_nicle.py~
z ukazom
#+BEGIN_SRC shell
python test_nicle.py
#+END_SRC
Če test ne izpiše ničesar, je koda uspešno prestala test. V nasprotnem primeru
program javi napako tipa ~AssertionError~ in prikaže mesto v testni kodi, kjer
je prišlo do napake.

Delovanje funkcije je smiselno preveriti na več različnih podatkih, po možnosti
naključno generiranih. Zato je v programu ~test_nicle.py~ več vrstic z ukazom
~assert~, ki funkcijo ~nicle~ preverijo na različne načine. Več o testiranju
programov, si oglejte na [[https://en.wikipedia.org/wiki/Test-driven_development][Wikipedii]].

#+BEGIN_SRC python :noweb strip-export :exports both :eval no-export :tangle test_nicle.py
  import random

  from nicle import nicle
  assert(nicle([-1, 0, 1, 2, 3], [1, -1, 1, 2, 3]) == [-0.5, 0.5])
  assert(nicle([1, 2, 3], [1, 1, 1]) == [])
  assert(nicle([2, 1, 3], [-1, -1, 1]) == [2.5])
  x = [random.random() for i in range(3)]
  y = [random.random() - 0.5 for i in range(3)] 
  x0 = nicle(x, y)
  m = min(x)
  M = max(x)
  for nicla in x0:
    assert(nicla < M) # preverimo, ali je rezultat manjši od največjega x
    assert(m < nicla)
#+END_SRC

#+RESULTS:

Datoteka s testi file:test_nicle.py
*** Rešitev
#+name: nicle
#+BEGIN_SRC python  :exports both :eval no-export :tangle nicle.py
  def nicle(x, y):
      # x-e najprej uredimo po velikosti
      x_in_indeksi = sorted(enumerate(x), key=lambda x: x[1])
      x = [element[1] for element in x_in_indeksi]
      # v istem vrstnem redu premešamo tudi y-ne
      indeksi = [element[0] for element in x_in_indeksi]
      y = [y[indeks] for indeks in indeksi] 
      x_n = []
      for i in range(len(x)-1):
          if y[i]*y[i+1]<0:
              nicla = (y[i+1]*x[i] - y[i]*x[i+1])/(y[i+1] - y[i])
              x_n.append(nicla)
      return x_n
#+END_SRC
#+RESULTS: nicle
Datoteka s programom file:nicle.py
** DONE Reševanje enačb z bisekcijo
   CLOSED: [2017-11-27 pon 11:12]
Reševanje vsake enačbe lahko prevedemo na iskanje ničel funkcije.
Preprosto prenesemo vse člene na eno stran enačbe. Zato se večina metod za
reševanje enačb prevede na iskanje ničel funkcije.
  
[[https://en.wikipedia.org/wiki/Bisection_method][Metoda bisekcije]] temelji na dejstvu, da ima vsaka zvezna funkcija, ki ima v
krajiščih intervala različna predznaka, na tem intervalu zagotovo vsaj
eno ničlo. Začnemo z intervalom, pri katerem ima funkcija na krajiščih različen
predznak. Nato izračunamo vrednost funkcije na sredini in izberemo
polovico intervala, kjer je predznak vrednosti funkcije različen. Postopek
ponavljamo, dokler interval ni dovolj majhen.

Napišite funkcijo ~bisekcija(f, interval, eps)~, ki z bisekcijo poišče interval,
krajši od ~eps~, na katerem zagotovo leži ničla funkcije $f$. Krajišči začetnega
intervala sta podani v seznamu ~interval~. Funkcija naj vrne seznam s krajišči
iskanega intervala. Če vrednosti na intervalu nimajo različnega predznaka, naj
funkcija javi napako tipa ~ValueError~.

Primer:

#+BEGIN_SRC python :noweb strip-export :results output :exports both :exports both :eval no-export
<<bisekcija>>
f = lambda x: x**2-2
print(bisekcija(f, (1,2), 0.3))
#+END_SRC

#+RESULTS:
: [1.25, 1.5]
Primer, ko funkcija nima ničle:
#+BEGIN_SRC python :results output :exports both :eval no-export
  <<bisekcija>>
  try:
    f = lambda x: x**2-2
    bisekcija(f,(2,3),0.3)
  except ValueError as err:
    print(type(err))
#+END_SRC

#+RESULTS:
: <class 'ValueError'>

*** Testi
Testiranje z ukazom ~assert~ ima omejitve, zato se za testiranje programov
uporablja knjižnice posebej namenjene pisanju testov. Poglejmo si uporabo
knjižnice [[https://docs.python.org/3/library/unittest.html][unittest]], ki je na voljo skupaj s Pythonom. Za vsak testni primer,
definiramo nov razred, ki je podrazred razreda ~unittest.TestCase~. Vse metode
našega razreda, ki se začnejo na ~test~, se obravnavajo kot testi in bodo
pognani ob klicu ~unittest.main()~. Lahko definiramo tudi druge pomožne metode, ki pa 
#+BEGIN_SRC python :results output :exports both :eval no-export :tangle test_bisekcija.py
from bisekcija import bisekcija
import unittest
class BisekcijaTest(unittest.TestCase):
      def test_primer(self):
          f1 = lambda x: x**2 - 2
          interval = bisekcija(f1, [1, 2], 0.3)
          self.assertEqual(interval, [1.25, 1.5])
          # preverimo, če vrne napako
          with self.assertRaises(ValueError):
              f2 = lambda x: x**2 + 2
              bisekcija(f2, [1, 2], 0.1)
      def test_implicitno(self):
          eps = 0.1
          f3 = lambda x: x**3 - x - 2
          interval = bisekcija(f3, [1, 2], eps)
          # preverimo lastnosti pravilne rešitve
          self.assertEqual(len(interval), 2)
          self.assertTrue(self.f3(interval[0])*self.f3(interval[1]) < 0)
          self.assertTrue(abs(interval[1] - interval[0]) < eps)

unittest.main()
#+END_SRC

#+RESULTS:

Datoteka file:test_bisekcija.py

*** Rešitev
#+name: bisekcija 
#+BEGIN_SRC python :exports both :eval no-export :tangle bisekcija.py
  def bisekcija(f, interval, eps):
      """Poišče podinterval intervala interval, ki je dolžine največ eps in na
      katerem ima funkcija f zagotovo ničlo z metodo bisekcije
      """
      a,b = interval
      fa, fb = (f(a),f(b))
      if fa*fb > 0:
          raise(ValueError("Vrednosti v krajiščih nimata različnih predznakov"))
      while abs(b-a) > eps:
          c = (a+b)/2
          fc = f(c)
          if fa*fc < 0:
              b, fb = c, fc
          elif fb*fc <0:
              a, fa = c, fc
          elif fc == 0:
              return [c,c]
      return [a,b]
#+END_SRC

Datoteka [[file:test_bisekcija.py][bisekcija.py]]
** Sekantna metoda
S [[https://sl.wikipedia.org/wiki/Sekantna_metoda][sekantno metodo]] konstruiramo zaporedje približkov za ničlo funkcije, tako da
začnemo z dvema približkoma. Nato izračunamo sekanto skozi točki na
grafu funkcije, ki ustrezata izbranima približkoma. Nov približek dobimo kot
presečišče sekante in x-osi. Postopek ponovimo z novim približkom in enim od
začetnih. Postopek nato ponavljamo, dokler vrednost funkcije $f(x_n)$ v zadnjem
približku $x_n$ ni manjša od vnaprej predpisanega števila $\varepsilon$.

Napiši funkcijo ~x0, iteracije = sekantna(f,a,b,eps,maxit=100)~, ki za Python
funkcijo ~f~ poišče približek za ničlo s sekantno metodo. Argumenta ~a~ in ~b~
sta začetna približka, ~eps~ je število $\varepsilon$, ki določi, kdaj smo našli
ničlo \[|f(x_n)|<\varepsilon,\] ~maxit~ pa je največje število iteracij, preden
prekinemo program, če ne najdemo ničle.

Funkcija ~sekantna~ naj vrne dve vrednosti. Prva vrednost naj bo približek za
ničlo ali ~None~, če ničle ne najdemo. Druga vrednost, ki naj jo ~sekantna~ vrne
naj bo število korakov sekantne metode, ki smo jih potrebovali, da smo prišli do
približka.

Primer enačbe $x^2-2=0$, katere rešitev je $\sqrt(2)$:
#+BEGIN_SRC python :exports both :results output :exports both :eval no-export
  <<sekantna>>
  f = lambda x: x*x-2
  x, iteracij = sekantna(f, 1, 2, 1e-5)
  print("Vrednost, ki jo dobimo s sekantno metodo po {} korakih: {}"
        .format(iteracij, x))
  print("Vrednost 2^0.5, ki jo vrne Python: {}".format(2**0.5))
#+END_SRC

#+RESULTS:
: Vrednost, ki jo dobimo s sekantno metodo po 4 korakih: 1.4142135620573204
: Vrednost 2^0.5, ki jo vrne Python: 1.4142135623730951

Še en primer za enačbo, ki nima ničel ($x^2+2=0$):
#+BEGIN_SRC python :exports both :results output :exports both :eval no-export
<<sekantna>>
f = lambda x: x*x+2
print(sekantna(f,1,2,1e-5))
#+END_SRC

#+RESULTS:
: (None, 100)

*** Rešitev
#+name: sekantna
#+BEGIN_SRC python :exports both :eval no-export
  def sekantna(f,a,b,eps, maxit=100):
      for n in range(maxit):
          fa, fb = f(a), f(b)
          b, a = b - fb*(b-a)/(fb-fa), b
          if abs(fb)<eps:
              return b,n
      return None,maxit
#+END_SRC

#+RESULTS: sekantna
: None

** Izračun vrednosti polinoma 
*** Hornerjev algoritem
** Kotne funkcije 
*** Tabela kotnih funkcij
Napiši program, ki generira tabeli kotnih funkcij $\sin$ in $\cos$ na intervalu
$[0,2\pi]$  v točkah $$x_i=i\frac{\pi}{100};\quad i=0,\ldots, 200.$$ Uporabi
adicijske izreka za sinus in cosinus
\begin{eqnarray*}
\sin(x+y)&=&\sin(x)\cos(y)+\sin(y)\cos(x)\\
\cos(x+y)&=&\cos(x)\cos(y) - \sin(x)\sin(y)
\end{eqnarray*}
in približne vrednosti
 $\sin(\frac{\pi}{100})\simeq \frac{\pi}{100}$ 
src_octave{disp(sin(pi/100))} {{{results(= 0.031411=)}}}
$\cos(\frac{\pi}{100})\simeq 1$
src_python{import math; return math.cos(math.pi/100)} {{{results(=0.9995065603657316=)}}}.

Dobljene vrednosti primerjaj z vrednostmi, ki jih vrneta funkciji ~math.sin~
in ~math.cos~, tako da poiščete razlike. Kolikšna je največja razlika med
vrednostjo, ki jo je izračunal vaš program in vrednostjo, ki jo je dala vgrajena
funkcija?   
*** Sinus in kosinus 1
Napiši funkcijo, ki izračuna vrednost funkcije $\sin(x)$ in $\cos(x)$ na
intervalu $[0,\frac{\pi}{2}]$, tako da uporabiš
adicijska izreka za dvojni kot
$$\sin(2x) = 2\sin(x)\cos(x),\quad \cos(2x)=\cos^2(x)-\sin^2(x)$$  
 in za majhne $x$ upošteva približni enakosti
$$\sin(x)\simeq x\text{ in } \cos(x)\simeq 1;\quad |x|<10^{-1}.$$
*** Sinus in kosinus 2
Funkcijo iz prejšnje naloge razširi na vsa realna števila. Uporabi periodičnost
in simetrije funkcij $\sin$ in $\cos$.
* Odvod
** Simbolično odvajanje

Naslednje naloge ilustrirajo, kako deluje simbolično odvajanje.
Napisati želimo funkcijo v Pythonu, ki izračuna odvod dane funkcije f.
Pri tem se omejimo le na funkcije, ki jih je mogoče izraziti z
osnovnimi operacijami ~+~, ~-~, ~*~, ~/~, s potenco ~a^b~ in funkcijami
~sin~, ~cos~, ~exp~ in ~log~.
Da bo programiranje lažje, bomo funkcijo zapisali v
[[http://sl.wikipedia.org/wiki/Obrnjeni_poljski_zapis][obrnjeni poljki notaciji]]([[http://en.wikipedia.org/wiki/Reverse_Polish_notation][uporabili bomo angleško kratico RPN]]).
*** RPN
Napiši razred ~RPN~, ki predstavlja funkcijo spremenljivke ~x~
podano v RPN obliki.
Razred naj ima atribut ~izraz~, ki naj bo niz oblike

#+BEGIN_EXAMPLE
    'arg1 arg2 op1 arg3 ... argn funk',
#+END_EXAMPLE

sestavljen iz besed, ločenih s presledki. Besede so lahko

 - argumenti: število ali ~'x'~,
 - operacije: ~'+'~, ~'-'~, ~'*'~, ~'/'~ ali ~'^'~
 - funkcije: ~'sin'~, ~'cos'~, ~'exp'~ ali ~'log'~.

Osnovne operacije zapišemo s 3 besedami

#+BEGIN_EXAMPLE
    1 + 1   -> '1 1 +'
    1 - 2   -> '1 2 -'
    2 * 3   -> '2 3 *'
    2 / 3   -> '2 3 /'
    2 ^ 3   -> '2 3 ^'
#+END_EXAMPLE
Funkcije ~sin~, ~cos~, ~exp~, ~log~ pa zapišemo z dvema besedama:

#+BEGIN_EXAMPLE
    sin(3.14) -> '3.14 sin'
    e^2.5     -> '2.5 exp'
#+END_EXAMPLE
Primeri
#+BEGIN_EXAMPLE
    1 + 2 + 3       -> '1 2 3 + +' ali '1 2 + 3 +'
    sin(2x)         -> '2 x * sin'
    sqrt(x)         -> 'x 0.5 ^'
    (x+1)/(x-1)     -> 'x 1 + x 1 - /'
    x^2+2x-1        -> 'x 2 ^ 2 x * -1 + +'
    log(sin(2/x+1)) -> '2 x / 1 + sin log'
#+END_EXAMPLE
Razred naj ima metodo ~__init__(izraz)~, ki inicializira atribut ~izraz~ in
metodo ~vrednost(arg)~, ki naj vrne vrednost izraza, če spremenljivko ~x~
zamenjamo z dano vrednostjo ~arg~.

Primer:

    >>> f = RPM('1 x +')
    >>> f.vrednost(1)
    2.0
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()

#+END_SRC
**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python :exports both :eval no-export
Check.part()
from math import sin
Check.equal("RPN('2 x *').vrednost(3)", 6)
Check.equal("RPN('2 x *').vrednost(-3)", -6)
Check.equal("RPN('1 x 2 ^ sin +').vrednost(3)", 1+sin(3**2))
Check.equal("RPN('1 x 2 ^ sin +').vrednost(3.14)", 1+sin(3.14**2))
f = RPN('x 1 + x 2 ^ / 3 x * 4 -')
g = RPN('x log sin cos exp')
for x in range(3):
    Check.secret(f.vrednost(x/4+1))
    Check.secret(g.vrednost(x/3+1))
#+END_SRC
*** Prikaz RPN izraza  
Razredu ~RPN~ dodaj metodo ~__str__~, ki vrne izraz zapisan klasično z
oklepaji in operatorji.
Primer:

    >>> f = RPM.new('3 x 2 x ^ + /')
    >>> print(str(f))
    (3/(x+(2^x)))
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()
    def __str__(self):
        sklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = '(' + str(a) + beseda + str(b) + ')'
                sklad.append(rezultat)
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = beseda + '(' + str(a) + ')'
                sklad.append(rezultat)
            else:
                sklad.append(str(beseda))
        return sklad.pop()

#+END_SRC
**** TODO Testi :noexport:
#+BEGIN_SRC python

Check.part()
Check.equal("str(RPN('2 x *'))", '(2*x)')
Check.equal("str(RPN('2 x x 3 ^ + *'))", '(2*(x+(x^3)))')
Check.equal("str(RPN('2 sin x x 3 ^ + *'))",'(sin(2)*(x+(x^3)))')
Check.secret(str(RPN('1 x cos x ^ sin +')))
Check.secret(str(RPN('1 log x / sin x +')))

#+END_SRC
*** Odvod RPN
Razredu ~RPN~ dodaj metodo ~odvod~, ki vrne objekt istega razreda, ki vsebuje
izraz za odvod po spremenljivki ~x~.

Primer:
#+BEGIN_EXAMPLE
    >>> f = RPM.new('1 x +')
    >>> df = f.odvod()
    >>> print(df.vrednost(1))
    1.0
#+END_EXAMPLE

Testnih primerov ne bomo navajali, ker je možno nalogo rešiti na več načinov,
pri katerih bo izraz za odvod različen (čeprav pravilen).
Za ilustracijo si poglejmo izraze

#+BEGIN_EXAMPLE
    '1 x +', 'x 1 +' in '1 x 1 + *',
#+END_EXAMPLE

ki predstavljajo isto funkcijo ~f(x)=x+1~.
Testiramo tako, da izračunamo vrednost odvoda v nekaj naključno izbranih
fiksnih točkah, s čimer pravilnost odvoda precej dobro preverimo.

Za začetek je dovolj, da metoda ~odvod~ deluje za izraze, ki ne vsebujejo potence ~'^'~.

**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    fodvod = {'sin': 'cos','cos':'sin -1 *','exp':'exp','log':'-1 ^'}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()
    def __str__(self):
        sklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = '(' + str(a) + beseda + str(b) + ')'
                sklad.append(rezultat)
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = beseda + '(' + str(a) + ')'
                sklad.append(rezultat)
            else:
                sklad.append(str(beseda))
        return sklad.pop()
    def odvod(self):
        dfsklad = []
        fsklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                df = dfsklad.pop()
                dg = dfsklad.pop()
                f = fsklad.pop()
                g = fsklad.pop()
                if beseda in ['+','-']:
                    # (f+g)' = f'+g'
                    df = ' '.join((df, dg, beseda))
                elif beseda == '*':
                    # (f*g)' = f'g + g'f
                    df = ' '.join((dg, f, '*', df, g, '* +'))
                elif beseda == '/':
                    df = ' '.join((g, df, '*', f, dg,'* -', g, '2 ^ /'))
                dfsklad.append(df)
                fsklad.append(' '.join((f, g, beseda)))
            elif beseda in self.funkcije.keys():
                # verižno pravilo (f(g(x)) = f'(x)*g'(x))
                df = dfsklad.pop()
                f = fsklad.pop()
                df = ' '.join((df,f,self.fodvod[beseda],'*'))
                dfsklad.append(df)
                fsklad.append(' '.join((f,beseda)))
            elif beseda == 'x':
                dfsklad.append('1')
                fsklad.append('x')
            else:
                dfsklad.append('0')
                fsklad.append(beseda)
        return RPN(dfsklad.pop())

#+END_SRC
**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python :exports both :eval no-export

Check.part()
from math import log,sin,cos
izraz = "RPN('x cos x log *').odvod()"
xi = (1.2,2.3,5,10.1,0.876,22.9876)
for x in xi:
    Check.equal(izraz + '.vrednost(%f)'%x ,cos(x)/x-log(x)*sin(x))
    Check.secret(RPN('x sin x cos /').odvod().vrednost(x))
    Check.secret(RPN('1 x sin + x 2 * log /').odvod().vrednost(x))

#+END_SRC
*** Odvod potence
Dopolni metodo ~odvod~, da deluje tudi za izraze, ki vsebujejo potenco ~^~.

Primer:

#+BEGIN_EXAMPLE
    >>> f = RPM('x 2 ^')
    >>> df = f.odvod()
    >>> print(df.vrednost(1))
    2.0
    >>> RPN('2 x ^').odvod().vrednost(0) # vrniti mora log(2)
    0.6931471805599453
#+END_EXAMPLE
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

import operator as op
from math import sin,cos,exp,log
class RPN:
    # slovarja s ključi, ki so imeni operacij in funkcij in vrednostmi, ki so
    # Python funkcije za te operacije.
    operacije = {'+': op.add,'-': op.sub,'*': op.mul, '/': op.truediv, '^': op.pow}
    funkcije = {'sin':sin,'cos':cos,'exp':exp,'log':log}
    fodvod = {'sin': 'cos','cos':'sin -1 *','exp':'exp','log':'-1 ^'}
    def __init__(self,izraz):
        self.izraz = izraz
    def vrednost(self,arg):
        sklad = [] # sklad, kjer hranimo delno izračunane vrednosti
        for beseda in self.izraz.split(' '):
            # ali smo prišli do opreracije
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = self.operacije[beseda](a,b)
                sklad.append(rezultat)
            # ali smo prišli do funkcije
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = self.funkcije[beseda](a)
                sklad.append(rezultat)
            elif beseda == 'x':
                sklad.append(arg)
            else:
                sklad.append(float(beseda))
        # na koncu dobimo v skladu le še končni rezultat
        return sklad.pop()
    def __str__(self):
        sklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                b = sklad.pop()
                a = sklad.pop()
                rezultat = '(' + str(a) + beseda + str(b) + ')'
                sklad.append(rezultat)
            elif beseda in self.funkcije.keys():
                a = sklad.pop()
                rezultat = beseda + '(' + str(a) + ')'
                sklad.append(rezultat)
            else:
                sklad.append(str(beseda))
        return sklad.pop()
    def odvod(self):
        dfsklad = []
        fsklad = []
        for beseda in self.izraz.split(' '):
            if beseda in self.operacije.keys():
                dg = dfsklad.pop()
                df = dfsklad.pop()
                g = fsklad.pop()
                f = fsklad.pop()
                if beseda in ['+','-']:
                    # (f+g)' = f'+g'
                    df = ' '.join((df, dg, beseda))
                elif beseda == '*':
                    # (f*g)' = f'g + g'f
                    df = ' '.join((dg, f, '*', df, g, '* +'))
                elif beseda == '/':
                    df = ' '.join((g, df, '*', f, dg,'* -', g, '2 ^ /'))
                elif beseda == '^':
                    # f(x)^g(x)' =f(x)^(g(x)-1)*(f(x)*log(f(x)*g'(x))+g(x)*f'(x))
                    df = ' '.join((f, g, '1 - ^', dg, f, f, 'log * *', df, g, '* + *'))
                dfsklad.append(df)
                fsklad.append(' '.join((f, g, beseda)))
            elif beseda in self.funkcije.keys():
                # verižno pravilo (f(g(x)) = f'(x)*g'(x))
                df = dfsklad.pop()
                f = fsklad.pop()
                df = ' '.join((df,f,self.fodvod[beseda],'*'))
                dfsklad.append(df)
                fsklad.append(' '.join((f,beseda)))
            elif beseda == 'x':
                dfsklad.append('1')
                fsklad.append('x')
            else:
                dfsklad.append('0')
                fsklad.append(beseda)
        return RPN(dfsklad.pop())

#+END_SRC
**** TODO Testi                                                    :noexport:

#+BEGIN_SRC python :exports both :eval no-export
Check.part()
from math import log,sin,cos
x = 1.2
xi = (0.1,1.2,2.3,1.1398,1.87,2.9876)
izraz1 = "RPN('x 1 + x log ^').odvod()"
izraz2 = "RPN('x x ^').odvod()"

for x in xi:
    Check.equal(izraz1 + '.vrednost(%f)'%x,(x+1)**log(x)*(log(x)/(x+1)+log(x+1)/x))
    Check.equal(izraz2 + '.vrednost(%f)'%x, x**x*(log(x)+1))
    Check.secret(RPN("1 x + x x * ^").odvod().vrednost(x))
#+END_SRC

** Avtomatsko odvajanje
Naloge ilustrirajo, kako deluje [[https://en.wikipedia.org/wiki/Automatic_differentiation][avtomatsko odvajanje]] računalniških programov.
Računalniški program je le zaporedje osnovnih računskih operacij. Kontrolne
strukture, kot so ~if~ stavek pa le odločijo, katero zaporedje računskih
operacij se bo izvedlo. Zato lahko programe odvajamo kot kompozitume funkcij. 
*** Preprosta funkcija
Funkcija $f$ je podana s Python definicijo
#+BEGIN_SRC python :exports both :eval no-export
  def f(x):
      "Funkcija f(x) = x^2"
      y = x**2
      return y
#+END_SRC
Sestavite funkcijo ~df(x)~, ki vrne vrednost odvoda funkcije $f$
izračunanega v točki ~x~.

Na primer klic ~f(1)~ naj vrne vrednost odvoda $f$ v ~1~:
#+BEGIN_EXAMPLE
    >>> df(1)
    2
    >>> df(2)
    4
#+END_EXAMPLE
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export
  def df(x):
      "Odvod funkcije x^2"
      return 2*x
#+END_SRC
**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python :exports both :eval no-export

Check.part()
Check.equal('df(3)', 6)
Check.equal('df(0.2)', 2*0.2)
Check.equal('df(-1)', -2)
Check.secret(df(42))
Check.secret(df(-123))

#+END_SRC
*** Malce bolj zapletena funkcija
Funkcija ~g(x)~ je podana s Python definicijo
#+BEGIN_SRC python :exports both :eval no-export
    def g(x):
      "Malce bolj zapletena funkcija."
      y = x**2
      y = x*(1/y+y)
      return round(y, 10)
#+END_SRC

Sestavite funkcijo ~dg(x)~, ki vrne vrednost odvoda ~g'(x)~ funkcije ~g~
izračunanega v točki ~x~. Končni rezultat zaokrožite z ~round(y,10)~,
preden ga funkcija ~dg~ vrne.

Na primer:
#+BEGIN_SRC python :exports both :eval no-export
    >>> dg(1)
    2
    >>> dg(2)
    11.75
#+END_SRC
**** Rešitev
Paziti moramo na vrstni red. Končni rezultat lahko zapišemo kot kompozitum
dveh $y_2(x)=x(\frac{1}{y_1(x)}+y_1(x))$, kjer je $y_1(x)=x^2$. Zanima nas
vrednost $y_2'(x)$. Uporabimo pravilo za produkt in verižno pravilo in dobimo, da je 
\[y_2'(x) = (\frac{1}{y_1(x)}+y_1(x))+x(-\frac{1}{y_1(x)^2}y_1'(x) + y_1'(x))\],
pri čemer je $y_1'(x)=2x$. Vrednost odvoda $y_2$ moramo izračunati, preden
povozimo vrednosti funkcije $y_1$ v spremenljivki ~y~ z novo vrednostjo.   
#+BEGIN_SRC python :exports both :eval no-export
# definicija z odvajanjem kode
def dg(x):
    "Odvod malce bolj zapletene funkcije"
    dy = 2*x
    y = x**2
    dy = (1/y+y)+x*(1-1/y**2)*dy
    y = x*(1/y+y)
    return round(dy,10)
#+END_SRC
**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python :exports both :eval no-export
# Definicija s formulo
def dg_formula(x):
    return round(x**2 + x*(2*x - 2/x**3) + x**(-2),10)
#+END_SRC
#+BEGIN_SRC python :exports both :eval no-export

Check.equal('dg(-1)', 2)
try:
    dg(0)
    Check.error("Klic dg(0) mora javiti napako!")
except:
    pass
# Testi za dg
#Testi za dg
cases = [(0.5, -3.25), (-0.5, -3.25), (1, 2.0), (-1, 2.0), (2, 11.75), (-2, 11.75), (4, 47.9375), (-4, 47.9375)]
for case in cases:
    x,dgv = case
    Check.equal('dg(%f)'% x, dgv)
Check.equal('dg(0.5)',-3.25)
Check.equal('dg(-4)', 47.9375)
Check.secret(dg(42))
for x in range(2,30,3):
    Check.secret(dg(x))
#+END_SRC
*** For zanka
Funkcija ~h(x)~ je podana s Python definicijo
#+BEGIN_SRC python
    def h(x):
      "Funkcija s for zanko."
      y = 1
      for n in range(10):
        y = (x/y+y)/2
      return round(y,10)
#+END_SRC

Sestavite funkcijo ~dh(x)~, ki vrne vrednost odvoda funkcije ~h(x)~
izračunanega v točki ~x~. Končni rezultat zaokrožite z ~round(y,10)~.

Na primer:

#+BEGIN_EXAMPLE
    >>> dh(1)
    0.5
    >>> dh(4)
    0.25
#+END_EXAMPLE

**** Namig
Predelajte kodo za funkcijo ~h~ tako, da hkrati s
funkcijo računate še njen odvod. Vsaki vrstici kode dodajte
vrstico v kateri posodobite vrednost odvoda. Pazite na vrstni red!
Katera pravila za odvajanje morate uporabiti?
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export
def dh(x):
    "Odvod funkcije s for zanko"
    dy = 0
    y = 1
    for n in range(10):
        dy = ((1*y-dy*x)/y**2+dy)/2
        y = (x/y+y)/2
    return round(dy,10)
#+END_SRC
**** TODO Testi :noexport:
#+BEGIN_SRC python :exports both :eval no-export
# funkcija h v resnici računa x^(1/2) s Haronovim obrazcem (tangentno metodo)
def dh_aprox(x):
    return round(x**(-0.5)/2,10)
#+END_SRC
#+BEGIN_SRC python :exports both :eval no-export
Check.part()
# Testi za dh
cases =  [(2, 0.3535533906, 0.7071067812),
          (3, 0.2886751346, 0.8660254038),
          (4, 0.25, 1.0),
          (5, 0.2236067977, 1.1180339887),
          (6, 0.2041241452, 1.2247448714),
          (7, 0.1889822365, 1.3228756555),
          (8, 0.1767766953, 1.4142135624),
          (9, 0.1666666667, 1.5)]
for case in cases:
    x,dh1,dh2 = case
    Check.equal('dh(%d)'% x, dh1)
    Check.equal('dh(1/%d)'% x,dh2)
for x in range(1,30,3):
    Check.secret(dh(x/10))
#+END_SRC
*** Kompozitum funkcij
Funkcija ~k~ je podana s pomožno funkcijo ~r(x)~
#+BEGIN_SRC python
        def r(x):
            "Pomožna funkcija."
            y = 1
            for i in range(1,10):
                y = x+y
                y = 1/(i*y)
            return y
        def k(x):
            "Funkcija, ki kliče drugo funkcijo."
            y = x
            for i in range(5):
                y = x*r(y)**2
            return y
#+END_SRC

Sestavite funkcijo ~dr(x)~ za ki izračuna odvod ~r'(x)~ in
~dk(x)~, ki vrne vrednost odvoda ~k'(x)~
izračunanega v točki ~x~.
Končni rezultat zaokrožite z ~round(y,10)~.

Na primer:
#+BEGIN_SRC python :exports both :eval no-export
    >>> dr(10)
    -0.001106963
    >>> dk(4)
    -0.0034362142
#+END_SRC

**** Namig
V ~dk(x)~ uporabite funkcijo ~dr(x)~ in verižno pravilo.
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

def r(x):
    y = 1
    for i in range(1,10):
        y = x+y
        y = 1/(i*y)
    return y
def k(x):
    y = x
    for i in range(5):
        y = x*r(y)**2
    return y
def dr(x):
    y = 1
    dy = 0
    for i in range(1,10):
        dy = 1+dy
        y = x+y
        dy = -(i*y)**(-2)*i*dy
        y = 1/(i*y)
    return round(dy,10)

def dk(x):
    y = x
    dy = 1
    for i in range(5):
        z = r(y)
        dy = z**2+x*2*z*dr(y)*dy
        y = x*z**2
    return round(dy,10)

#+END_SRC
**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python  :exports both :eval no-export

Check.part()
def drsym(x):
    return round(-(1625702400*x**16 + 3251404800*x**15 + 9852917760*x**14 + 13203025920*x**13 + 20623343616*x**12 + 19717742592*x**11 + 19865630592*x**10 + 13868455680*x**9 + 9604790272*x**8 + 4865480192*x**7 + 2321094784*x**6 + 820537216*x**5 + 256614880*x**4 + 57572480*x**3 + 10056136*x**2 + 898800*x + 240360)/(14631321600*x**18 + 29262643200*x**17 + 94163005440*x**16 + 129800724480*x**15 + 218471779584*x**14 + 221236075008*x**13 + 246177055872*x**12 + 188496315648*x**11 + 149388195600*x**10 + 86951121696*x**9 + 50053354416*x**8 + 21790548000*x**7 + 8964450216*x**6 + 2790466560*x**5 + 772383960*x**4 + 155310120*x**3 + 24824025*x**2 + 2485350*x + 99225),10)

def dk_fd(x):
    # finite diference method for derivative
    h = 2**(-20)
    dy = -k(x+2*h)+8*k(x+h)-8*k(x-h)+k(x-2*h)
    dy = dy/12/h
    return round(dy,10)

try:
    dr(-1)
    Check.error("Klic dr(-1) bi moral javiti napako!")
except:
    pass
Check.equal('dk(4)',-0.0034362142)

# Testi za dr in dk
cases =  [(0, -2.4223733938, 0.0557006013),
          (2, -0.025432294, 0.0892606704),
          (3, -0.0118554566, 0.0981358769),
          (5, -0.004378945, 0.1103474705),
          (6, -0.0030546628, 0.1148118927),
          (9, -0.0013654262, 0.12455767)]
for case in cases:
    x, drv, dkv = case
    Check.equal('dr(%d)'%x, drv)
    Check.equal('dk(1/%d)'%(x+1),dkv)
for x in range(1,30,3):
    Check.secret(dk(x/10))
    Check.secret(dr(x/10))
#+END_SRC
*** TODO Program kot zaporedje(kompozitum) preprostih operacij     :noexport:
** Numerično odvajanje
*** Deljene diference za prvi odvoda
*** Deljene diference za drugi odvod
** Tangenta in normala
* Integral 
** Nedoločeni integral
*** Integral polinoma
Napiši funkcijo ~integral(p)~, ki izračuna integral polinoma ~p~. Polinom 
$$p(x) = a_n x^n + a_{n-1}x^{n-1}+\ldots + a_1 + a_0$
naj bo podan s seznamom koeficientov ~p~ $=[a_n,a_{n-1},\ldots a_0]$.

Primer:

#+BEGIN_SRC python :exports both :results output :exports both :eval no-export
<<integral>>
p = [1,1,1,1] # polinom x^3 +  x^2 + x + 4
print(integral(p))
#+END_SRC

#+RESULTS:
: [0.25, 0.3333333333333333, 0.5, 1.0, 0]

**** Rešitev
#+name: integral
#+BEGIN_SRC python :exports both :eval no-export
  def integral(p):
      n = len(p)
      return [p[i]/(n-i) for i in range(n)] + [0]
#+END_SRC
** Določeni integral
*** Trapezna formula za določeni integral
Napiši funkcijo ~trapez(f,a,b,n)~, ki izračuna približek integrala
$$\int_a^bf(x)dx.$$ kot vsoto ploščin trapezov, ki jih dobimo, če interval
$[a,b]$ razdelimo na podintervale $[x_i,x_{i+1}]$ enake dolžine in povežemo
točke $(x_i,0)$, $(x_{i+1},0)$, $(x_{i+1},f(x_{i+1}))$ in $(x_i,f(x_i))$ (glej
sliko).

#+header: :imagemagick yes :iminoptions -density 1000 :imoutoptions -geometry 600 
#+header: :exports results :file trapez.png
#+header: :packages '(("" "pgfplots")) :border 1em :results raw
#+header: :header '("\\pgfplotsset{compat=newest}")
#+BEGIN_SRC latex
\pgfplotsset{
    integral axis/.style={
        axis lines=middle,
        enlarge y limits=upper,
        axis equal image, width=12cm,
        xlabel=$x$, ylabel=$y$,
        ytick=\empty,
        xticklabel style={font=\small, text height=1.5ex, anchor=north},
        samples=100
    },
    integral/.style={
            domain=2:10,
            samples=5
    },
    integral fill/.style={
            integral,
            draw=none, fill=#1,
            %on layer=axis background
        },
        integral fill/.default=gray!10,
        integral line/.style={
            integral,
            very thick,
            draw=#1
        },
        integral line/.default=black
}


\begin{tikzpicture}[
    % The function that is used for all the plots
    declare function={f=(2*x^3-33*x^2+144*x)/50;}
]
\begin{axis}[
    integral axis,
    ymin=0,
    xmin=0.75, xmax=11.25,
    domain=1.5:10.5,
    xtick={2,...,10},
    xticklabels={$a$,,$\ldots$,,$x_{i}$,,$x_{i+1}$,,$b$},
    axis on top
]
% The filled area under the approximate integral
\addplot [integral fill=gray!15] {f} \closedcycle;

% The highlighted segment
\addplot [integral fill=gray!35, domain=6:8, samples=2] {f} \closedcycle;

% The function
\addplot [very thick, blue!75] {f} node [anchor=south] {$y=f(x)$};

% The approximate integral
\addplot [integral line=black] {f};

% The vertical lines between the segments
\addplot [integral, ycomb] {f};

\end{axis}
\end{tikzpicture}
#+END_SRC

#+RESULTS:
[[file:trapez.png]]
Primer:
#+BEGIN_SRC python :results output :exports both :exports both :eval no-export
  <<trapez>>
  f = lambda x: x**2 
  print(trapez(f,0,1,1))
#+END_SRC

#+RESULTS:
: 0.5
**** Namig
Velja
$$\int_{x_i}^{x_{i+1}}f(x)dx=\int_{a}^{x_{1}}f(x)dx+\int_{x_1}^{x_{2}}f(x)dx+\ldots
\int_{x_{n-1}}^{b}f(x)dx,$$
S formulo za izračun ploščine trapeza
$$P=v\frac{a+b}{2}$$ izpeljite približek za integral
$$\int_{x_i}^{x_{i+1}}f(x)dx$$
in formulo za integral na intervalu $[a,b]$ dobite kot vsoto ploščin posameznih
trapezov. 
**** Matematična izpeljava
Če interval $[a,b]$ razdelimo na $n$ enakih delov, lahko krajišča podintervalov
izračunamo kot $x_i = a+ih$, kjer je $h=\frac{b-a}{n}$ dolžina podintervala.
Ploščina trapeza z oglišči $(x_i,0)$, $(x_{i+1},0)$, $(x_{i+1},f(x_{i+1}))$ in
$(x_i,f(x_i))$ je enaka
$$(x_{i+1}-x_i)\frac{f(x_i)+f(x_{i+1})}{2}=h\frac{f(x_i)+f(x_{i+1})}{2}.$$
Integral lahko torej približno ocenimo z vsoto 
 
 $$\int_a^bf(x) dx \simeq \sum_{i=0}^{n-1} h\frac{f(x_{i+1})+f(x_i))}{2}
= \frac{h}{2}\sum_{i=0}^{n-1}(f(x_i)+f(x_{i+1})).$$ 
Vsoto lahko preuredimo
\begin{multline*}
\frac{h}{2}\sum_{i=0}^{n-1}\left(f(x_i)+f(x_{i+1})\right)=\frac{h}{2}\left(\sum_{i=0}^{n-1}f(x_i)+\sum_{i=0}^{n-1}f(x_{i+1})\right)=\\
\frac{h}{2}\left(\sum_{i=0}^{n-1} f(x_i) + \sum_{i=1}^{n}f(x_i)\right) = 
\frac{h}{2}\left(f(a)+2\sum_{i=1}^{n-1}f(x_i)+f(b)\right),
\end{multline*}
tako, da se vrednost $f(x_i)$ pojavi le enkrat. Tako dobimo 
/sestavljeno trapezno pravilo/ za izračun integrala
$$
\int_a^bf(x)dx \simeq \frac{h}{2}\left(f(a)+2\sum_{i=1}^{n-1}f(x_i)+f(b)\right).
$$
 
**** Rešitev
#+name: trapez
#+BEGIN_SRC python :exports both :eval no-export
  def trapez(f,a,b,n):
      h = (b-a)/n
      return h/2*(f(a)+2*sum(f(a+(i+1)*h) for i in range(n-1))+f(b))
#+END_SRC

**** Testi
*** Dolžina loka krivulje
Napiši funkcijo ~dolzina(f,a,b,n)~, ki izračuna dolžino loka grafa funkcije
$f(x)$ kot vsoto dolžin daljic, ki jih dobimo, če razdelimo interval $[a,b]$ na
podintervale $[x_i,x_{i+1}]$ enake dolžine in povežemo točke
$$(x_i,f(x_i))$ (glej sliko). 

Rezultat primerjaj s približkom, ki ga dobiš, če
uporabiš formulo za dolžino loka
$$l=\int_a^b \sqrt{1+f'(x)^2}dx$$
in trapezno formulo za izračun integrala.

#+header: :imagemagick yes :iminoptions -density 1000 :imoutoptions -geometry 600 
#+header: :exports results :file dolzina.png
#+header: :packages '(("" "pgfplots")) :border 1em :results raw
#+header: :header '("\\pgfplotsset{compat=newest}")
#+BEGIN_SRC latex
\pgfplotsset{
    integral axis/.style={
        axis lines=middle,
        enlarge y limits=upper,
        axis equal image, width=12cm,
        xlabel=$x$, ylabel=$y$,
        ytick=\empty,
        xticklabel style={font=\small, text height=1.5ex, anchor=north},
        samples=100
    },
    integral/.style={
            domain=2:10,
            samples=5
    },
    integral fill/.style={
            integral,
            draw=none, fill=#1,
            %on layer=axis background
        },
        integral fill/.default=gray!10,
        integral line/.style={
            integral,
            very thick,
            draw=#1
        },
        integral line/.default=black
}


\begin{tikzpicture}[
    % The function that is used for all the plots
    declare function={f=(2*x^3-33*x^2+144*x)/50;}
]
\begin{axis}[
    integral axis,
    ymin=0,
    xmin=0.75, xmax=11.25,
    domain=2:10,
    xtick={2,...,10},
    xticklabels={$a$,,$\ldots$,,$x_{i}$,,$x_{i+1}$,,$b$},
    axis on top
]
% The filled area under the approximate integral
% \addplot [integral fill=gray!15] {f} \closedcycle;

% The highlighted segment
% \addplot [integral fill=gray!35, domain=6:8, samples=2] {f} \closedcycle;

% The function
\addplot [very thick, blue!75] {f} node [anchor=south] {$y=f(x)$};

% The approximate integral
\addplot [integral line=black] {f};

% The vertical lines between the segments
% \addplot [integral, ycomb] {f};

\end{axis}
\end{tikzpicture}
#+END_SRC

#+RESULTS:
[[file:dolzina.png]]

Primer:
#+BEGIN_SRC python :exports both :results output  :exports both :eval no-export
<<trapez>>
<<dolzina>>
f = lambda x: x**2
print(dolzina(f,0,1,1))
#+END_SRC

#+RESULTS:
: 1.4142135623730951
#+BEGIN_SRC python :exports both :results output  :exports both :eval no-export
  <<trapez>>
  <<dolzina>>
  f = lambda x: x**2
  for n in range(5):
      print(dolzina(f,0,1,2**(2*n)))
#+END_SRC

#+RESULTS:
: 1.4142135623730951
: 1.4742804757093162
: 1.4786516869545336
: 1.4789246603146189
: 1.4789417202213675
Primerjamo še s trapezno formulo
#+BEGIN_SRC python :exports both :results output  :exports both :eval no-export
  <<trapez>>
  <<dolzina>>
  dl = lambda x: (1+4*x**2)**0.5
  for n in range(5):
      print(trapez(dl,0,1,2**(2*n)))
#+END_SRC

#+RESULTS:
: 1.618033988749895
: 1.4882642944012199
: 1.479525185093328
: 1.478979251951247
: 1.4789451321908484
**** Namig
Dolžina daljice med točkama $(x_0,y_0)$ in $(x_1,y_1)$ je enaka
$$\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}.$$
**** Rešitev
Označimo s $h=x_{i+1}-x_i$ dolžino podintervalov. Razdalja med $(x_i,f(x_i))$ in
$(x_{i+1},f(x_{i+1}))$ je tako enaka
$$ \sqrt{h^2+(f(x_{i+1})-f(x_i))^2}.$$
#+name: dolzina
#+BEGIN_SRC python :exports both :eval no-export
  def dolzina(f,a,b,n):
      """Izračuna približek za dolžine loka grafa funkcije f na intervalu [a,b],
      tako da krivuljo aproksimira z lomljenko sestavljeno iz n daljic."""
      h = (b-a)/n
      d = 0
      for i in range(n):
          dy = f(a+(i+1)*h) - f(a+i*h)
          d += (h**2 + dy**2)**0.5
      return d
#+END_SRC
* Vektorji v ravnini in prostoru 
** Vektorji
*** Python razred za vektorje
Spodaj napisani preprost razred ~Vektor~ predstavlja vektorje kot $n$-terice števil.
#+name: Vektor
#+BEGIN_SRC python :exports both :eval no-export
  class Vektor:
      def __init__(self, *vred):
          if len(vred)==1 and hasattr(vred,'__getitem__'):
              self.vrednosti = tuple(vred[0])
          else:
              self.vrednosti = tuple(vred)
      def __getitem__(self, k):
          return self.vrednosti[k]
      def __iter__(self):
          return self.vrednosti.__iter__()
      def __len__(self):
          return len(self.vrednosti)
      def __str__(self):
          return str(self.vrednosti)
#+END_SRC

Razred ~Vektor~ razširi z naslednjimi metodami 
- ~__add__~
- ~__sub__~
- ~__mul__~
- ~__rmul__~
ki predstavljajo osnovne operacije med vektorji oziroma med vektorji in števili.

Primer:

#+BEGIN_SRC python :results output :exports both :eval no-export
<<Vektor>>
<<Vektor_osnove>>
a = Vektor(1,2,3)
b = Vektor(3,2,1)
print(a+b, a-b, 2*a,b*0.5)
#+END_SRC

#+RESULTS:
: (4, 4, 4) (-2, 0, 2) (2, 4, 6) (1.5, 1.0, 0.5)

**** Rešitev
#+name: Vektor_osnove
#+BEGIN_SRC python :exports both :eval no-export
  def __add__(self,b):
      return Vektor(ai + bi for ai,bi in zip(self,b))
  def __sub__(self,b):
      return Vektor(ai - bi for ai,bi in zip(self,b))
  def __mul__(self,alfa):
      return Vektor(alfa*ai for ai in self)
  def __rmul__(self,alfa):
      return self.__mul__(alfa)

  setattr(Vektor, '__add__', __add__)
  setattr(Vektor, '__rmul__', __rmul__)
  setattr(Vektor, '__sub__', __sub__)
  setattr(Vektor, '__mul__', __mul__)
#+END_SRC
*** Skalarni in vektorski produkt
Definiraj funkciji ~dot(a,b)~ in ~cross(a,b)~, ki izračuna skalarni in vektorski
produkt dveh vektorjev ~a~ in ~b~.
#+name: dot_cross¸
#+BEGIN_SRC python :exports both :eval no-export
  def dot(a,b):
      return sum(ai*bi for ai, bi in zip(a,b))
  def cross(a,b):
      return Vektor(a[1]*b[2]-a[2]*b[1],
                    a[2]*b[0]-a[0]*b[2],
                    a[0]*b[1]-a[1]*b[0])

#+END_SRC

#+RESULTS:
: None

*** Enakost, kolinearnost in koplanarnost vektorjev
 Npiši funkcijo ~kolinearna(a,b)~, ki preveri ali sta dva vektorja ~a~ in ~b~
 kolinearna in vrne ~True~, če sta kolinearna in ~False~, če nista.
 Vektorja ~a~ in ~b~ sta bodisi seznama tipa ~list~ ali n-terici tipa ~tuple~.
 
 Na primer:
#+BEGIN_SRC python :session kolinearna :results output :exports both :exports both :eval no-export
kolinearna([3,2], [6,4]), kolinearna((0,0,1), (1,0,0))
#+END_SRC

#+RESULTS:
: (True, False)
**** Rešitev
#+name: kolinearna
#+BEGIN_SRC python :session kolinearna :exports both :eval no-export
  def kolinearna(a, b):
      n, m = len(a), len(b)
      if n != m:
          # vektorja nista enakih dimenzij
          return False
      for i in range(n):
          if a[i] !=0:
              # we have found the pivot
              k = b[i]/a[i]
              prvi, drugi = a, b
              break
          elif b[i] != 0:
              k = a[i]/b[i]
              prvi, drugi = b,a
              break
      for j in range(i+1,n):
          if k*prvi[j] != drugi[j]:
              return False
      return True
#+END_SRC

#+RESULTS: kolinearna

**** TODO Testi                                                    :noexport:
Check.part()
Check.equal('kolinearna([1,2,3], [2,4,6])', True)
Check.equal('kolinearna([0,0,0,0], [1,2,3,4])', True)
Check.equal('kolinearna([1,0], [1,0,0])', False)
Check.secret(kolinearna([0,0,1],[0,0,2]))
Check.secret(kolinearna([1,2],[-1,-2]))
Check.secret(kolinearna([0,0,1],[0,1,-2]))
*** Koplanarni vektorji 
Npiši funkcijo ~koplanarni(a,b,c)~, ki preveri ali trije 3D vektorji ~a~, ~b~ in ~c~
ležijo na isti ravnini in vrne ~True~, če ležijo in ~False~ sicer.
Vektorji ~a~, ~b~ in ~c~ so bodisi seznama tipa ~list~ ali n-terici tipa ~tuple~.

Na primer:

#+BEGIN_SRC python :results output :exports both :exports both :eval no-export
print(koplanarni([3,2,0], [6,4,0],[-1,2,0]))
print(koplanarni((1,0,0), (0,1,0),(0,0,1)))
#+END_SRC
**** Rešitev
#+name: koplanarni
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    "Izračuna skalarni produkt dveh vektorjev"
    return sum(x[i]*y[i] for i in range(len(x)))
def cross(x,y):
    "Izračuna vektorski produkt dveh vektorjev"
    return (x[1]*y[2]-x[2]*y[1], x[2]*y[0]-x[0]*y[2], x[0]*y[1]-x[1]*y[0])

def koplanarni(a, b, c):
    # pri koplanarnih vektorjih je mešani produkt enak 0
    return dot(a,cross(b,c)) == 0
#+END_SRC
**** TODO Testi                                                    :noexport:
Check.part()
Check.equal('koplanarni([1,2,0], [2,4,0],[-2,3,0])', True)
Check.equal('koplanarni([1,0,0], [0,1,0],[0,0,1])', False)
Check.equal('koplanarni([1,2,2], [0,1,2],[0,0,1])', False)
Check.equal('koplanarni([1,0,-3], [0,1,0],[1,1,-3])', True)
Check.equal('koplanarni([1,2,3], [0,1,2],[0,0,0])', True)
Check.equal('koplanarni([0,1,0], [0,1,2],[1,0,1])', False)
Check.secret(koplanarni([1,1,2], [2,1,2],[1,2,1]))
Check.secret(koplanarni([1,2,1], [1,1,1],[1,3,1]))
Check.secret(koplanarni([2,2,2], [1,-2,1],[1,1,1]))
Check.secret(koplanarni([1,1,0], [0,1,2],[1,-1,1]))
*** Linearna odvisnost
Napiši funkcijo ~odvisni(*vektorji)~, ki preveri ali so dani vektorji
linearno odvisni in vrne ~True~, če so odvisni in ~False~, če niso.
Vektorji so lahko poljubne dimenzije. Uporabiš
lahko metodo ~linalg.matrix_rank~ iz knjižnice ~numpy~.

Na primer:

#+BEGIN_SRC python :exports both :eval no-export
    >>> odvisni([1,1],[1,2],[3,4])
    True
    >>> odvisni([1,2,3],[1,2,4])
    False
#+END_SRC
**** Rešitev
#+name: odvisni
#+BEGIN_SRC python :exports both :eval no-export
import numpy as np
def odvisni(*vektorji):
    matrika = np.array(vektorji)
    return np.linalg.matrix_rank(matrika)<len(vektorji)
#+END_SRC
**** TODO Testi                                                    :noexport:

#+BEGIN_SRC python :exports both :eval no-export
Check.part()
Check.equal('odvisni(list(range(10)),10*[1])', False)
Check.equal('odvisni(3*[1],3*[2],3*[0])', True)
Check.equal('odvisni([1,0,0],[0,1,1],[0,1,-1])', False)
Check.secret(odvisni([1,1,1],[1,2,3],[0,0,0]))
Check.secret(odvisni([1,1,1],[1,1,2],[0,1,0]))
#+END_SRC

** Premica in ravnina v 3D
*** Razred za ravnino v prostoru
Sestavite razred ~Ravnina~, ki predstavlja ravnino v prostoru.
Razred naj ima metodo ~__init__(self,n,T)~, ki ravnino določi z normalo in točko
in metodo ~vsebuje(self,T)~, ki preveri ali točka ~T~ leži na ravnini.
Na primer:

#+BEGIN_SRC python  :exports both :eval no-export
R = Ravnina([1,1,1],[0,0,0]) # ravnina x+y+z=0
R.vsebuje([1,0,-1])
#+END_SRC

Dopolnite razred ~Ravnina~ z metodo ~__eq__(self,other)~, ki preveri
ali objekta ~self~ in ~other~ predstavljata isto ravnino.

Na primer:

    >>> Ravnina([1,1,1],[0,0,0]) == Ravnina([-1,-1,-1],[1,0,-1])
    True

**** Rešitev

#+name: ravnina
#+BEGIN_SRC python :exports both :eval no-export
from numpy import dot
class Ravnina:
    def __init__(self,n,T):
        self.n = n # koeficientni a b c
        self.d = dot(n,T) # koeficient d
        self.T = T #
    def vsebuje(self,T):
        return dot(self.n,T) == self.d
    def __eq__(self,other):
        a,b,c,d = self.n+[self.d]
        e,f,g,h = other.n+[other.d]
        # preverimo, če sta vektorja koeficientov kolinearna (ne najbolj optimalno)
        return a*f == b*e and a*g==c*e and b*g==c*f and a*h==d*e and b*h==d*f and c*h==d*g
#+END_SRC
**** TODO Testi                                                    :noexport:

#+BEGIN_SRC python :exports both :eval no-export
Check.part()
Check.equal('Ravnina([1,2,3],[1,0,0]).vsebuje([0,-1,1])', True)
Check.equal('Ravnina([1,2,3],[1,0,0]).vsebuje([0,1,1])', False)
Check.secret('Ravnina([1,2,3],[1,2,3]).vsebuje([0,1,1])')
Check.secret('Ravnina([1,2,3],[1,2,3]).vsebuje([14,0,0])')

Check.part()
Check.equal('Ravnina([1,2,3],[1,0,0])==Ravnina([1,2,3],[0,-1,1])', True)
Check.equal('Ravnina([1,2,3],[1,0,0])==Ravnina([2,4,6],[1,0,1])', False)
Check.equal('Ravnina([1,2,3],[1,0,0])==Ravnina([2,4,6],[1,0,0])', True)
Check.secret('Ravnina([1,2,3],[1,2,3])==Ravnina([1,2,3],[1,2,-3])')
Check.secret('Ravnina([1,2,3],[1,2,3])==Ravnina([3,6,9],[14,0,0])')
Check.secret('Ravnina([0,0,3],[1,2,3])==Ravnina([1,2,3],[14,0,0])')
Check.secret('Ravnina([0,2,0],[1,2,3])==Ravnina([0,1,0],[1,2,3])')
#+END_SRC
*** Razred za premico v prostoru
Sestavite razred ~Premica~, ki predstavlja premico v prostoru.
Razred naj ima metodo ~__init__(self,e,T)~, ki premico določi
s smernim vektorjem ~e~ in točko ~T~. Razred naj ima tudi metodo ~skozi_tocke(A,B)~, ki naj vrne premico skozi točki ~A~ in ~B~ in metodo
~__eq__(self,p)~, ki preveri ali sta dve premici enaki.

Na primer:
#+BEGIN_SRC python :exports both :eval no-export

    >>> p = Premica([1,2,3],[0,1,2]) # premica x=t,y=1+2t,z=2+3t
    >>> q = Premica.skozi_tocke([0,1,2],[1,3,5])
    >>> p == q
    True
#+END_SRC
**** Rešitev

#+name: premica
#+BEGIN_SRC python :exports both :eval no-export
from numpy import dot
class Premica:
    def __init__(self,e,T0):
        self.e = e # koeficientni a b c
        self.T0 = T0 # točka na premici
    def skozi_tocke(A,B):
        e = [B[i]-A[i] for i in range(len(A))] # e=B-A
        return Premica(e,A)
    def __eq__(self,other):
        # preverimo, če sta smerna vektorja koeficientov kolinearna in
        # če je vektor med dvema točkama na premicah tudi
        # vzporeden s smernima vektorjema
        a,b,c = self.e
        d,e,f = other.e
        T0T = [self.T0[i]-other.T0[i] for i in range(3)] # razlika
        r,s,t = T0T
        return a*s == b*r and a*t==c*r and b*t==c*s and a*e == b*d and a*f==c*d and b*f==c*e
#+END_SRC
**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python

Check.part()
Check.equal('Premica([1,2,3],[1,0,0])==Premica([-1,-2,-3],[0,-2,-3])', True)
Check.equal('Premica([1,2,0],[1,0,0])==Premica([2,4,0],[2,2,0])', True)
Check.equal('Premica([1,2,0],[1,0,0])==Premica([2,4,0],[2,1,0])', False)
Check.equal('Premica([1,2,0],[1,0,0])==Premica.skozi_tocke([1,0,0],[2,2,0])', True)
Check.equal('Premica.skozi_tocke([1,1,1],[3,5,1])==Premica([2,4,0],[2,1,0])', False)
Check.secret('Premica([1,2,3],[1,2,3])==Premica([1,2,3],[1,2,-3])')
Check.secret('Premica([1,2,3],[1,2,3])==Premica([1,2,3],[0,0,0])')
#+END_SRC
#+END_SRC
*** Presečišče premice in ravnine
Napišite funkcijo ~presecisce(p,R)~, ki izračuna presečišče
premice ~p~ in ravnine ~R~. če presečišča ni
ali jih je neskončno naj funkcija javi napako tipa
~Exception('Presečišča ni ali jih je neskončno')~. 
Argument ~p~ naj bo razreda ~Premica~, ~R~ pa razreda ~Ravnina~.

Na primer:

#+BEGIN_SRC python :exports both :eval no-export
    >>> presecisce(Premica([1,2,3],[1,2,3]), Ravnina([1,1,1],[1,2,3]))
    [1,2,3]
    >>> presecisce(Premica([1,0,-1],[0,0,1]), Ravnina([1,1,1],[0,0,2]))
    None
#+END_SRC

**** Rešitev
#+name: presecisce
#+BEGIN_SRC python :exports both :eval no-export

from numpy import dot
from numpy.linalg import solve
class Ravnina:
    def __init__(self,n,T):
        self.n = n # koeficientni a b c
        self.d = dot(n,T) # koeficient d
    def vsebuje(self,T):
        return dot(self.n,T) == self.d

class Premica:
    def __init__(self,e,T0):
        self.e = e # koeficientni a b c
        self.T0 = T0 # točka na premici
    def skozi_tocke(A,B):
        e = [B[i]-A[i] for i in range(len(A))] # e=B-A
        return Premica(e,A)

def presecisce(p,R):
    if dot(p.e,R.n)==0:
        raise Exception('Nič ali neskončno presečišč!')
    t = (R.d-dot(R.n,p.T0))/dot(R.n,p.e)
    return [p.T0[i]+t*p.e[i] for i in range(3)]

#+END_SRC

**** TODO Testi                                                    :noexport:

#+BEGIN_SRC python :exports both :eval no-export
Check.part()
Check.equal('presecisce(Premica([1,2,3],[0,-2,-3]),Ravnina([-1,-2,-3],[0,-2,-3]))', [0,-2,-3])
try:
    koda = 'presecisce(Premica([1,2,0],[1,0,0]),Ravnina([2,-1,0],[2,2,0]))'
    eval(koda)
    Check.error('%s bi moralo javiti napako.'%koda)
except Exception as ex:
    errmsg = "Nič ali neskončno presečišč!"
    if ex.args[0] != errmsg:
        Check.error("Če je presečišč neskončno ali nobenega, mora funkcija javiti napako z Exception('%s')" % errmsg)
Check.equal('presecisce(Premica([1,2,3],[1,0,0]),Ravnina([-1,-2,-3],[-4,0,-3]))', [0,-2,-3])
Check.equal('presecisce(Premica.skozi_tocke([1,1,1],[0,2,2]),Ravnina([-1,0,1],[0,2,1]))',[0.5,1.5,1.5])
for i in range(10):
  Check.secret('presecisce(Premica([1,2+i,3],[0,1,i]),Ravnina([-1+i,-2,-3],[0,-2,-3]))')
Check.secret('presecisce(Premica.skozi_tocke([1,2,3],[0,2,1]),Ravnina([-1,-2,-3],[0,-2,-3]))')
#+END_SRC

** Raytracing: krogla in točkasto svetilo
Pri tej nalogi bomo generirali sliko krogle osvetljene z enim točkastim svetilom 
v praznem prostoru.
*** Presečišče poltraka in ravnine
Napiši funkcijo ~presecisce(poltrak, krogla)~, ki izračuna prvo presečišče
poltraka in krogle oziroma vrne ~None~, če presečišča ni. Poltrak naj bo podan
kot par trojic ~(T0,e)~, kjer je ~T0~ začetna točka poltraka, ~e~ pa smerni
vektor. Krogla naj bo tudi par  ~(S,r)~, kjer je ~S~ trojica koordinat središča
krogle in ~r~ polmer. Če je izhodišče poltraka znotraj krogle, naj funkcija vrne
~None~. 

Primer:

#+BEGIN_SRC python :exports both :eval no-export
    >>> presecisce(((0,0,0),(1,0,0)), ((2,0,0),1))
    (1,0,0)
    >>> presecisce(((0,0,0),(-1,0,0)), ((2,0,0),1)) # vrne None
    >>> presecisce((0,0,0),(1,0,0)), ((0,0,0),1)) # vrne None
#+END_SRC

**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    return sum(x[i]*y[i] for i in range(len(x)))

def presecisce(poltrak, krogla):
    T0, e = poltrak
    S, r = krogla
    # vektorska enacba krogle (rT - rS).(rT - rS)=r
    # rT.rT - 2rT.rS + rS.rS - r = 0
    # enacba poltraka rT = rT0 + t*e
    # presecisce doloca kvadratna enacba
    # (rT0 + t*e).(rT0 + t*e) - 2(rT0 + t*e).rS + rS.rS - r = 0
    # e.e*t^2 + 2*rT0.e*t + rT0.rT0 -2*rT0.rS - 2*e.rS*t + rS.rS - r = 0
    a = dot(e,e)
    b = 2*(dot(e,T0)-dot(e,S))
    c = dot(T0,T0) - 2*dot(T0,S) + dot(S,S) - r*r
    D = b**2 - 4*a*c
    if D<0:
        return None
    t = (-b-D**0.5)/(2*a)
    if t<0:
        return None
    else:
        return tuple(T0[i]+t*e[i] for i in range(len(T0)))

#+END_SRC
Check.part()
Check.equal('presecisce(((0,0,0),(1,0,0)), ((2,0,0),1))', (1,0,0))
Check.equal('presecisce(((0,0,0),(-1,0,0)), ((2,0,0),1.5))', None)
Check.equal('presecisce(((0,0,0),(1,0,0)), ((0,0,0),2))', None)
Check.secret(presecisce(((1,1,1),(1,1,1)),((2,0,0),1)))
Check.secret(presecisce(((1,2,-1),(-1,2,2)),((2,3,1),3)))
Check.secret(presecisce(((1,0,1),(1,2,1)),((2,1,-1),2)))
Check.secret(presecisce(((1,0,1),(1,2,2)),((5,10,0),6)))

*** Osvetljenost
Napiši funkcijo ~osvetljenost(T, krogla, svetilo)~, ki določi osvetljenost točke ~T~ na obodu krogle ~krogla=(S,r)~,
če kroglo osvetlimo s svetilom v točki ~S~. Osvetljenost izračunamo s formulo
$$\frac{\cos{\alpha}}{r^2},$$
kjer je $r$ razdalja med točko na krogli in svetilom, kot $\alpha$ pa je kot med normalo na kroglo dani točki in vpadnim žarkom (daljico,
ki točko $T$ povezuje s svetilom).
Če je kot $\alpha$ večji kot $\pi/2$, naj funkcija vrne $0$.
Primer:

    >>> osvetljenost((1,0,0),((2,0,0),1), (0,0,0))
    1
    >>> osvetljenost((1,0,0),((2,0,0),1),(4,0,0))
    0
    >>> osvetljenost((1,0,0),((2,0,0),1),(0,3**0.5,0))
    0.125

**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    return sum(x[i]*y[i] for i in range(len(x)))

def osvetljenost(T, krogla, svetilo):
    S, r = krogla
    L = svetilo
    n = tuple(T[i]-S[i] for i in range(len(S)))
    TL = tuple(L[i]-T[i] for i in range(len(T)))
    return max(0, dot(n,TL)/dot(n,n)**0.5/dot(TL,TL)**1.5)

#+END_SRC
Check.part()
Check.equal('osvetljenost((1,0,0),((2,0,0),1), (0,0,0))', 1)
Check.equal('osvetljenost((1,0,0),((2,0,0),1),(4,0,0))', 0)
Check.equal('osvetljenost((1,0,0),((2,0,0),1),(0,3**0.5,0))', 0.125)
Check.secret(osvetljenost((1,0,0),((2,0,0),1),(1,3**0.5,0)))
Check.secret(osvetljenost((0,0,0),((2,0,0),2),(-1,3,0)))

*** Krogla osvetljena s točkastim svetilom 
Napiši funkcijo ~pogled(kamera,okvir, krogla, svetilo, slika)~, ki izdela sliko (~slika~ tipa ~PIL.Image~) ~krogle~ osvetljene s ~svetilom~,
ki jo naredi ~kamera~ skozi dani ~okvir~.

Parametri:

- ~kamera~: trojica koordinat položaja kamere v prostoru
- ~okvir~: par ~(A,u,v)~, kjer je ~A~ oglišče, ~u~ in ~v~ pa vektorja stranic paralelograma $ABCD$
- ~krogla~: par ~((xs,ys,zs),r)~
- ~svetilo~: par ~((xl,yl,zl),P)~, kjer je prva trojica predstavlja koordinate svetila, ~P~ pa je število, sorazmerno moči svetila.
- ~slika~ : objekt tipa ~PIL.Image~, ki ga dobimo z ukazom ~PIL.Image('F',(n,m),"black")~

Vrednost piksla z indeksi $(i,j)$ na sliki, naj bo enaka osvetljenosti
$$\frac{P\cos\alpha}{r^2}$$
točke na krogli, ki jo zadane žarek iz kamere skozi točko v okvirju
$$\vec{r}_T=\vec{r}_{A}+\frac{i}{n}\vec{u}+\frac{m-j}{m}\vec{v}.$$

Primer:

#+BEGIN_SRC python :exports both :eval no-export
    >>>from PIL import Image
    >>>slika = Image.new('F',(255,255),"black")
    >>>kamera = (0,0,0); okvir = ((1,-1,-1),(0,2,0),(0,0,2));
    >>>krogla = ((2,0,0),1); svetilo = ((0,-3,0),500);
    >>>pogled(kamera, okvir, krogla, svetilo, slika)
    >>>slika.show()
#+END_SRC

Prikaže sliko
#+BEGIN_EXPORT html
<img alt="Slika krogle" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAP8AAAD/CAAAAAAbY18WAAAJ20lEQVR4nO2dTas0RxXH/9VPzAfILstssskmZJFVFgEXwYW4EAQxEFADQkQluogiqCCahYqKguALBCIBwU/4ZOq46O7qc06d6hm7Xrqvnv/Td/pleu6t33mrmnmmqwGXy+VyuVwul8vlcrlcLpfL5XK5XC6Xy+VyuVwul8vlcrlcLpfL5XK5XC6Xy+VyXVHhzD/+IhFRPLMFp/C/FEAgIiKKRBQpEp3QDADD+V+eAFrg4/IQZxOMbciqkfyvQMEv7p8j4BwLvDDqD726BT0RUYhEsy1ABAqRcEolGMP/2gKP1fEzepyI4rQsIJxQBkbE/+vY4p4F/pL7rASckAPd+d+YAqmsX6kF/UllsHP8v8noIzCtqzj/RGCKfJlGG6Av/1thRkeEgGfkwgABow3Qk/9tYK34E+XwCGm1LlNEwFAD9OP/oujwImbYldiATyYYaYBu/O9gG+SCOZ6BC/IpbtsDDdCJ/0sBoLU7n5L3Jbjgp/A/xP9lpMzfIj8Dpyz412WcAXrwfyWErcsT7Bk4BcMKNLAGduD/6tzpAXm5L4DPO2kZmQHt+b8GsLonHa+DnlML9w/LgOb8X0d6G2M6Pne3PjoboXW7CmrN/67h/D3q/InFCIMM0Jb/3WfC+bqPu0stlqYtK6kp/3vT4v3F+Q9hnorflP+b0+p90/GXtEBD/m8v3o9yZM/q2vXwW/J/YfF+cn6GfUELTM1+0wfTNE1hFkJAvkZabwf2lhFq5v/vgSgLfO144V9CON//rfh/gFT5BPzKqtd32eezuqtR/H84sehPMZ9CXsf/dTKgjf9/OAcr9/zq7iwKmOsvkAFt/P9Ccn3yvPQ98lDAAyHQX034fxzW4McW9jL+AcbM10anwJbuasH/kwQfMniIlWGDk0tAC/5nLPIVfI5f9v8pCdCA/2dh2pwv7SDx93KglAa9Vc//8zBp6AwfRg5Ark9KgHr+OfkteOgseCAIRidANf8vRdcXbHzAMABfl23QWdX8k2bOSp9ZBpQhdhKhr2r5PzZcH3i45/4XwKr+KfrQ3QCV/B+HyfI3DhkgD4LL+//ZBD7m0dzINpkBTOTRBqjj/82a/ZKbFwS9iWIRZDYZZ4A6fjboN/2vY8DqBfbor17/J8lu4QsTQA0BHukC+qqK/w8B64d7qYAb+NIEaQ+a+owOsIqff7QpXbpCGyaA8vwd+gvn/5+mLGa3HABY261OAA/S9zVADX+Kfo0PnQPYDgFQdtA1UP2NvqriX9E1vlUAdkrAbv/XWRX8f2HO3woAEp6QWQJEAUTafyL5vxBn7TXin2XAsgEOXs6AK+d/Sv69EjifaRjBzABsm2PCv4L/r5hbuPzIFJ5XQVoizwEo+vEdwHH+EJLzs9ZK8N0cANh5Q1wuVMM//6QgmI+K8qcSYTcHyiWwpw7z/51H+5YDIgA2qTwAOxEafagO80+L87MSoNxsh4BdBNdTBgbAYf6N3qiAkNDpCPf8XhcwTnXjv/Ro5r8xAgAMen70ydT/FUlFQHp2/1WqOOy/qKeO8n+Czfn/RQKkzW11vwL2tMtR/sCanYOmDSMBSgOAcgXsqcP8WG3Ai1fIWYzXoXTKCQlQM/5nqyydrfeAOb2ZAEN13P+6kOW5kA+BxKnlX72321gV9Z+tlC3UeEcPBsWvMPuMUdlf/f8/5X7u7muu0QPW1D+B8mBwn9LJ76ju8+9s994IqNhVnhUCB/n/CdQ11Yr+M1Tf/xWdenggN7IDOMh/sSw+rnbf/3+acv7/bx3kP22+qtaq8D9lG3I/t9GDVqPd3bY6yP8NoK5hVNgerar8zx1FpecKR/PzBxvjKD+xRxB2ssF84WVUWf9LNHuURnk4yfmo4BcUCon4aeu/wq8wM4bY0lfH41+7keQuP0fv7VONLP8N+j/lxXSg6HHztWdlQE39I+ZyGbFlit0YOKE2Hr3+kbJH/Rx48pM8uJ2WRwCkMTvb5Kj/31sanZquG5wnQF4AzPA/PGw8pIr6L6P/kdGPVTYh4Ierpv+nLQS4Z4mHgNH/2XVTRsCwDDju/60CPh7+0vl5AXhC45/ILCAMYAZAEolTHql+F+3/v8X7Op7/iU8Pfg5Wv746nv9E0vvLUVXnLefb7i8XgJ6q4V8tQFl7ZdiLvVL3j3MKwHH+96FjnySPOfIpZj9bP4n6j3Xubu1+KmX/TuwXE6C7qvhhBD9zcdb769in3AKK+br1H/jO6v/ZFBwnb3Me+xv0bvG7bP2bE0CEgIx/IwSInVTw/UB2oJJ/KwHKANoE2A5BRn+Gnf2Nvqrh/25MAHbxU5VfcT9Y+/taoGr+I1oTf0t/Ef0yDCCTX/v+FPy6z3+/nzKAVmOU0h+l5CfOORy/cv6ruGHz2C/D6yopE2g8fuXn/3G5lQezQWYAsPQng3yv+vfvAOr4fxQ5fgIV+GoTmeNpzwK9TVA5/9stIIWA4X/YpV+wGh3IOPza///6iOLm7czpeRgw/Dz9T8Cv/v7HR9stjTY75B3BI/iU4RN1N0D1/IdRpruwA/TmZoUHi//l/Y+fRhJCTq38r0PAdv2g+l8//2UEFLZhAAOf6C57f/wW87+td3XaMwDbK4TAU41/4BcUKd3eS5vC9r/perKW3mrx/b9bsQdQBiCbnbQlxoV/E/5fxXUczMdCVDCAWt/LgM5q8v3PX1OM7K2AMsHd2DcDf0z4N5r/+PPA05/FQeHhUf/3V5vv//42Rkm/waYDOgHorvNH+L/R959/F2PcbADDDub65ORHu+9//z4bBuaet6N/Z2nUtj01+/77H2/rHS21CYz1VaK/5ff//8wyoERtePjU6G96/4/n691vyLSCdv8DywA1vP7jb5/HtQrGzArXpG97/cs/nt9UFTTC4WIGaHr9zyfPYxQd4QHose5vfiHfdv8zsu5vvC3FJ9alccMKan3916e3mw4BOxLuhMgo/ze//u2zWyoCrBLuAed1chx+h+v//nWLpRDYtYQ82LxZBXW4/vHfz28rfGRVQMLbrk9H27eqoD4XMov73/JU0LXv3OKHbhdyL/c/tmxgmUEvfRplqduF7Pz+16RCwOKnyLZ7NSpXvwv51f3P+cO9sUG3NuXqOZHB25BviHYrwbqMxe88kcNbYXnjEx8zwdjaB3SfyOLNKaROLe7Vws0CfRuk1X0ijzeYBbgJ7BowGn/IRCavA9twJ4og4BYYH/wYNZHLa0tfgBQClv8Hlz4AAyeyeVV0h1kZiBRHDnuSRk7k8wqgKkHiPyX2geETGb08KROcVvgWnTGR00tBDI3PSfxFp05k9SLR0Dc7LpfL5XK5XC6Xy+VyuVwul8vlcrlcLpfL5XK5XC6Xy+VyuVwul8vlcrlcLpfL9YT0Hytr/dbuB1MpAAAAAElFTkSuQmCC">
      #+END_EXPORT

#+BEGIN_SRC python :exports both :eval no-export
    >>> slika.getpixel((100,100))
    85.13904571533203
#+END_SRC
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    return sum(x[i]*y[i] for i in range(len(x)))
def plus(x,y):
    return [x[i]+y[i] for i in range(len(x))]
def minus(x,y):
    return [x[i]-y[i] for i in range(len(x))]
def mul(alfa,x):
    return [alfa*x[i] for i in range(len(x))]

def osvetljenost(T, krogla, svetilo):
    S, r = krogla
    L = svetilo
    n = tuple(T[i]-S[i] for i in range(len(S)))
    TL = tuple(L[i]-T[i] for i in range(len(T)))
    return max(0, dot(n,TL)/dot(n,n)**0.5/dot(TL,TL)**1.5)

def presecisce(poltrak, krogla):
    T0, e = poltrak
    S, r = krogla
    # vektorska enacba krogle (rT - rS).(rT - rS)=r
    # rT.rT - 2rT.rS + rS.rS - r = 0
    # enacba poltraka rT = rT0 + t*e
    # presecisce doloca kvadratna enacba
    # (rT0 + t*e).(rT0 + t*e) - 2(rT0 + t*e).rS + rS.rS - r = 0
    # e.e*t^2 + 2*rT0.e*t + rT0.rT0 -2*rT0.rS - 2*e.rS*t + rS.rS - r = 0
    a = dot(e,e)
    b = 2*(dot(e,T0)-dot(e,S))
    c = dot(T0,T0) - 2*dot(T0,S) + dot(S,S) - r*r
    D = b**2 - 4*a*c
    if D<0:
        return None
    t = (-b-D**0.5)/(2*a)
    if t<0:
        return None
    else:
        return tuple(T0[i]+t*e[i] for i in range(len(T0)))

def pogled(camera, okvir, krogla, svetilo, slika):
    n, m = slika.size
    cv, u, v = okvir
    bc, r = krogla
    light, W = svetilo
    pixels = slika.load()
    for i in range(n):
        xvi = plus(cv, mul(i/n,u)) # xvi = cv + i*dx
        for j in range(m):
            xvij = plus(xvi, mul((m-j)/m,v)) # xvij = xvi + j*dy
            e_ray = minus(xvij, camera) # e_ray = xvij - camera
            # (x-bc)(x-bc)-r=0 => x.x -2x.bc + bc.bc - r = 0
            # x = camera + t*e_ray
            # x.x = camera.camera + 2*t*e_ray.camera + t**2*e_ray.e_ray
            # x.bc = camera.bc + t*e_ray.bc
            a = dot(e_ray,e_ray)
            b = 2*dot(e_ray,camera) - 2*dot(e_ray,bc)
            c = dot(camera,camera) - 2*dot(camera,bc) + dot(bc,bc) - r
            D = b**2 - 4*a*c
            if D<0:
                continue
            t1 = (-b - D**0.5)/(2*a)
            t2 = (-b + D**0.5)/(2*a)
            if t1 >= 1:
                t = t1
            elif t2 >= 1:
                t = t2
            else:
                continue
            P = plus(camera, mul(t,e_ray))
            lv = minus(light, P)
            norm = minus(P, bc)
            if dot(norm,lv)<=0:
                continue
            cos = W*dot(norm,lv)/a**0.5/dot(norm,norm)**0.5/dot(lv,lv) # cosine/r^2
            pixels[i,j] = cos
    return slika

#+END_SRC

**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python :exports both :eval no-export

Check.part()
from PIL import Image
slika = Image.new('F',(255,255),"black")
kamera = (0,0,0); okvir = ((1,-1,-1),(0,2,0),(0,0,2)); krogla = ((2,0,0),1); svetilo = ((0,-3,0),500);
pogled(kamera, okvir, krogla, svetilo, slika)
slika.show()
pixels = slika.load()
#print(pixels[100,100])
# generiramo sliko za tekst
#import base64
#from io import BytesIO
#buf = BytesIO()
#slika.convert(mode='L').save(buf, format="PNG")
#print("<img alt=\"Slika krogle\" src=\"data:image/png;base64,%s\">"%base64.b64encode(buf.getvalue()))

Check.equal('slika.getpixel((0,0))', 0)
Check.equal('slika.getpixel((100,100))', 85.13904571533203)
Check.secret(slika.getpixel((100,125)))

#+END_SRC

** Raytracing: tetraeder in točkasto svetilo

Na Khan academy Pixar [[https://www.khanacademy.org/partner-content/pixar/rendering][prikazuje]], kako delajo risane filme.
Pomemben del procesa, ki pripelje do končnega izdelka je tudi metoda 
„sledenja žarkom“(angl. raytracing), ki omogoča verno poustvarjanje osvetlitve.
Ta naloga ilustrira, kako deluje „raytracing“.

*** Presečišče poltraka in ravnine

Definiraj funkcijo ~presek(p, R)~ ki vrne presečišče poltraka ~p~ in ravnine ~R~.
Če presečišča ni, naj funkcija vrne ~None~. Poltrak je podan kot par dveh točk (trojice števil),
kjer je prva točka začetna točka poltraka, druga pa poljubna točka na poltraku. Npr. poltrak
~p=((0,0,0),(1,0,0))~ predstavlja pozitivni del osi $x$.
Ravnina je podana s koeficienti enačbe $ax+by+cz=d$ kot četvorka števil ~R=(a,b,c,d)~(tuple).

Primer:

#+BEGIN_SRC python :exports both :eval no-export

    >>> presek(((0,0,2),(0,0,1)), (1,1,1,0))
    (0,0,0)
    >>> presek(((0,0,1),(0,0,2)), (1,1,1,0)) #vrne None
    >>>

#+END_SRC

**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))

def presek(p, R):
    T0,T = p
    e = tuple(T[i]-T0[i] for i in range(len(T))) # smerni vektor poltraka
    n = R[0:3] # normala ravnine
    # enačbo poltraka x = T0 + t*e vstavimo v enačbo ravnine n.x=d
    # in dobimo enačbo n.(T0 + t*e)=d iz katere izrazimo t
    # t = (d - n.T0)/(n.e)
    a = dot(n,e)
    if a==0:
        return None # p in R vzporedni
    t = (R[3]-dot(n,T0))/a
    if t<0:
        return None
    else:
        return tuple(T0[i]+t*e[i] for i in range(len(T0)))

#+END_SRC

**** TODO Testi                                                    :noexport:

#+BEGIN_SRC python :exports both :eval no-export

Check.part()
Check.equal('presek(((0,0,2),(0,0,1)),(1,1,1,0))', (0,0,0))
Check.equal('presek(((0,0,1),(0,0,2)),(1,1,1,0))', None)
Check.equal('presek(((1,1,1),(2,2,2)),(1,-1,0,2))',None)
Check.secret(presek(((1,1,1),(1,2,2)),(1,2,3,4)))
Check.secret(presek(((1,2,2),(1,1,1)),(3,2,1,-4)))
Check.secret(presek(((1,0,2),(1,1,1)),(0,2,1,1)))
Check.secret(presek(((1,2,2),(1,1,1)),(3,2,0,2)))
Check.secret(presek(((1,2,0),(1,1,0)),(3,0,1,-4)))

#+END_SRC

*** Na kateri strani ravnine leži točka?

Definiraj funkcijo ~stran(T,R)~, ki pove na kateri strani ravnine ~R~ leži točka ~T~. 
Funkcija naj vrne ~1~, če točka leži nad ravnino (glede na smer normale), ~-1~, če točka leži pod ravnino
in ~0~, če je točka na ravnini. 
Točka je podana kot trojica (tuple) števil ~T=(0,0,0)~,
ravnina pa s koeficienti enačbe $ax+by+cz=d$ kot četvorka števil ~R=(a,b,c,d)~(tuple).
#### Primer:

    >>> stran((0,0,1), (0,0,1,0))
    1
    >>> stran((0,0,-1), (0,0,1,0))
    -1
    >>> stran((0,0,0),(0,0,1,0))
    0

**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))

def stran(T, R):
    n = R[0:3] # normala ravnine
    # stran nam pove predznak izraza ax+by+cz-d
    s = dot(n,T)-R[3]
    if s==0:
        return 0 # T leži na R
    elif s>0:
        return 1
    else:
        return -1

#+END_SRC

**** TODO Testi                                                    :noexport:
#+BEGIN_SRC python :exports both :eval no-export

Check.part()
Check.equal('stran((0,0,1),(0,0,1,0))', 1)
Check.equal('stran((0,0,-1),(0,0,1,0))', -1)
Check.equal('stran((0,0,2),(1,1,1,0))', 1)
Check.equal('stran((0,1,1),(-2,1,1,2))', 0)
Check.equal('stran((1,0,1),(2,2,1,4))', -1)
Check.secret(stran((2,-3,1),(2,2,1,3)))
Check.secret(stran((4,-3,1),(2,2,1,3)))
Check.secret(stran((2,-3,1),(2,-5,1,3)))
Check.secret(stran((0,-3,1),(-1,0,1,-3)))
Check.secret(stran((0.5,-3,1),(2,2,1,6)))

#+END_SRC

*** Ali leži dana točka na trikotniku ABC?

Večina modelov teles v 3D je sestavljena iz majhnih trikotnikov(triangulirana),
zato mora program za raytracing vedeti, če svetlobni žarek zadene trikotnik in
ne le ravnino trikotnika. Točka $T$ leži v trikotniku $\triangle ABC$ natanko
tedaj, ko velja:  

 - točka $T$ leži na ravnini trikotnika
 - točki $C$ in $T$ ležita na isti strani ravnine, ki vsebuje $AB$ in je pravokotna na trikotnik
 - točki $A$ in $T$ ležita na isti strani ravnine, ki vsebuje $BC$ in je pravokotna na trikotnik
 - točki $B$ in $T$ ležita na isti strani ravnine, ki vsebuje $AC$ in je pravokotna na trikotnik

Definiraj funkcijo ~na_trikotniku(T,trikotnik)~, ki pove ali dana točka ~T~ leži
na danem trikotniku. Funkcija naj vrne ~true~ ali ~false~. Robovi in oglišča so
tudi del trikotnika.  

Točka je podana kot trojica (tuple) števil ~T = (0,0,0)~,
trikotnik pa kot trojica točk ~trikotnik = ((1,2,3), (4,5,6), (3,2,1))~.

Primer
#+BEGIN_SRC python :exports both :eval no-export

    >>> na_trikotniku((1,1,0), ((0,0,0), (3,0,0), (0,3,0)))
    True
    >>> na_trikotniku((1,1,0), ((0,0,1), (3,0,1), (0,3,1))) # točka ne leži na ravnini trikotnika
    False
    >>> na_trikotniku((1,1,0), ((0,0,0), (2,0,0), (0,2,0))) # točka leži robu
    True
    >>> na_trikotniku((1,1,0), ((0,0,0), (1,0,0), (0,1,0))) # točka leži ravnini a ne znotraj trikotnika
    False

#+END_SRC
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))
def cross(x,y):
    "Funkcija izračuna vektorski produkt dveh vektorjev"
    return (x[1]*y[2] - x[2]*y[1], x[2]*y[0] - x[0]*y[2], x[0]*y[1] - x[1]*y[0])

def na_trikotniku(T,ABC):
    A, B, C = ABC
    a = [B[i]-A[i] for i in range(len(A))]
    b = [C[i]-B[i] for i in range(len(B))]
    c = [A[i]-C[i] for i in range(len(C))]
    n = cross(a,b) # normala ravnine trikotnika
    d = dot(n,A) # desna stran enacbe
    if dot(T,n) != d:
        return False # ne leži na ravnini
    # ravnina, ki vsebuje AB in je pravokotna na trikotnik
    na = cross(n,a)
    da = dot(A,na)
    if (dot(T,na) - da)*(dot(C,na) - da) < 0:
        # T in C sta na nasprotnih straneh stranica AB
        return False
    # ravnina, ki vsebuje BC in je pravokotna na trikotnik
    nb = cross(n,b)
    db = dot(B,nb)
    if (dot(T,nb) - db)*(dot(A,nb) - db) < 0:
        # T in A sta na nasprotnih straneh BC
        return False
    # ravnina, ki vsebuje CA in je pravokotna na trikotnik
    nc = cross(n,c)
    dc = dot(C,nb)
    if (dot(T,nc) - dc)*(dot(B,nc) - dc) < 0:
        # T in B sta na nasprotnih straneh CA
        return False
    else:
        return True

#+END_SRC
Check.part()
Check.equal('na_trikotniku((1,1,0), ((0,0,0), (3,0,0), (0,3,0)))', True)
Check.equal('na_trikotniku((1,1,0), ((0,0,1), (3,0,1), (0,3,1)))', False)
Check.equal('na_trikotniku((1,1,0), ((0,0,0), (2,0,0), (0,2,0)))', True)
Check.equal('na_trikotniku((1,1,0), ((0,0,0), (1,0,0), (0,1,0)))', False)
Check.equal('na_trikotniku((1,1,1), ((3,0,0), (0,3,0), (0,0,3)))', True)
Check.equal('na_trikotniku((1,2,-1), ((3,0,0), (0,3,0), (0,0,3)))', False)
Check.secret(na_trikotniku((1,2,3), ((0,1,3), (-1,0,3), (1,3,2))))
Check.secret(na_trikotniku((1,1,0), ((0,0,0), (3,0,0), (0,3,0))))
Check.secret(na_trikotniku((1,1,2), ((1,2,-3), (3,-3,-1), (2,3,3))))
Check.secret(na_trikotniku((1,1,-2), ((0,0,0), (3,1,-1), (1,3,5))))
Check.secret(na_trikotniku((1,-2,0), ((0,0,0), (3,1,2), (0,3,1))))
Check.secret(na_trikotniku((0,0,0), ((1,-1,0), (3,-2,-1), (-2,3,-1))))
Check.secret(na_trikotniku((1,1,2), ((0,0,0), (3,0,0), (0,3,0))))
Check.secret(na_trikotniku((1,1,0.5), ((0,0,1.5), (3,0,0), (0,3,0))))
*** Kam se odbije žarek

Definiraj funkcijo ~odboj(p, R)~, ki pove, kam se odbije svetlobni žarek, ki ga predstavlja poltrak ~p~, ko vpade na ravnino ~R~.

Funkcija naj vrne par ~(T,e)~, kjer je ~T~ začetna točka odbitega žarka in ~e~ smerni vektor, ki kaže v smeri odbitega žarka in
je enake dolžine kot ~e0~.

Poltrak je podan kot par ~p = (T0,e0)~, kjer je ~T0~ začetna točka, ~e0~ pa smerni vektor.
Ravnina je podano kot četvorka koeficientov ~R = (a,b,c,d)~ enačbe ravnine $ax+by+cz=d$. Če
poltrak ne zadene ravnine, naj funkcija vrne ~None~.

Primer

#+BEGIN_SRC python :exports both :eval no-export

    >>> odboj(((0,0,1), (1,0,-1)), (0,0,1,0))
    ((1,0,0),(1,0,1))
    >>> odboj(((0,0,1), (-1,0,1)), (0,0,1,0)) # poltrak ne seka ravnine
    None

#+END_SRC
**** Rešitev
#+BEGIN_SRC python :exports both :eval no-export

def dot(x,y):
    "Funkcija izračuna skalarni produkt dveh vektorjev."
    return sum(x[i]*y[i] for i in range(len(x)))

def odboj(p, R):
    T0, e0 = p
    n = R[0:3]
    d = R[3]
    # enacba poltraka rT = rT0 + t*e0
    # enacba ravnine n.(rT) = n.(rT0 + t*e0) = n.rT0 + t*(n.e0) = d
    # t = (d - n.rT0)/(n.e0)
    cos = dot(n,e0)
    if cos == 0:
        # poltrak in ravnina sta vzporedni
        return None
    t = (d - dot(n,T0))/cos
    if t<0:
        #poltrak ne seka ravnine
        return None
    # Presecisce poltraka in ravnine
    T = tuple(T0[i] + t*e0[i] for i in range(len(T0)))
    # odbojni smerni vektor je enak e0 - 2*proj_n(e0)
    proj = cos/dot(n,n)
    e = tuple(e0[i] - 2*proj*n[i] for i in range(len(n)))
    return (T,e)

#+END_SRC
#+BEGIN_SRC python :exports both :eval no-export

Check.part()
Check.equal('odboj(((0,0,1),(1,0,-1)), (0,0,1,0))', ((1,0,0),(1,0,1)))
Check.equal('odboj(((0,0,1),(-1,0,1)), (0,0,1,0))', None)
Check.secret(odboj(((0,1,1),(1,-1,0)), (1,1,1,0)))
Check.secret(odboj(((0,1,0),(1,-1,0)), (0,2,1,2)))
Check.secret(odboj(((2,1,0),(1,-1,5)), (0,3,1,-3)))
Check.secret(odboj(((1,0,-3),(1,1,4)), (0,4,1,-5)))
Check.secret(odboj(((0,1,3),(-1,-1,3)), (0,5,1,1)))
Check.secret(odboj(((0,1,1),(-2,-1,2)), (1,6,1,1)))

#+END_SRC
**** Ali točka leži na trikotniku?
*** TODO Večkratni odboji :noexport:
* Matrike in sistemi enačb 
** Matrike
*** Python razred za matrike
** Sistemi enačb
*** Gaussova eliminacija
Napišite funkcijo, ki izvede Gaussovo eliminacijo na matriki podani kot dvojni
seznam.
*** Polinomska interpolacija
Napišite funkcijo ~f = interpoliraj(x,y)~, ki vrne funkcijo ~f~, ki izračuna vrednosti
interpolacijskega polinoma, ki interpolira podatke ~x~ in ~y~.
*** Maksimum funkcije podane s tabelo
Napišite funkcijo ~maksimum(x,y)~, ki poišče približno vrednost lokacije
maksimuma in vrednosti maksima s pomočjo kvadratne interpolacije.  
* Licenca 
#+BEGIN_EXPORT html
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
<img alt="Creative Commons licenca" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
</a><br />
<span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Matematika skozi Python</span>, 
avtorja <a xmlns:cc="http://creativecommons.org/ns#" href="https://mrcinv.github.io" property="cc:attributionName" rel="cc:attributionURL">Martin Vuk</a> 
je objavljena pod licenco <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Priznanje avtorstva-Deljenje pod enakimi pogoji 4.0 Mednarodna licenco</a>.
<br />Za dodatna dovoljenja, ki presegajo obseg te licence, kontaktirajte avtorja. 
#+END_EXPORT
