* Zaporedja in vrste
** Zaporedja
V vsakdanjem življenju pojem zaporedja pogosto
pomeni seznam elementov, pri katerem je pomemben vrstni red. Na primer zaporedje
plesnih korakov v koreografiji, zaporedje števil pri lotu ali pa zaporedje
postajališč na liniji mestnega prometa. Matematike seveda zanima vse kar je
povezano z neskončnostjo, zato si pod pojmom zaporedja predstavljamo neskončna
zaporedja, ki jih formalno definiramo kot funkcijo $\mathbb{N}\to A$, ki vsakemu
naravnemu številu $n$ priredi nek element množice $a_n=a(n)\in A$. Element $a_n$ imenujemo $n$-ti
člen zaporedja.  V Pythonu so neskončni objekti nepraktični[fn:generator], zato so zaporedja povezana s
podatkovnim tipom ~list~, ki predstavlja končni seznam elementov in zankami
~for~ in ~while~, s katerimi se sprehodimo po elementih seznama in izvedemo
zaporedje korakov.
[fn:generator] Tudi v Pythonu poznamo posplošitev pojma končnega zaporedja
in to je [[https://wiki.python.org/moin/Generators][generator]], ki je še najbližje matematičnemu pojmu zaporedja].
*** Naloga
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: naloga
    :END:
Zapiši približne vrednosti prvih 100 členov zaporedja $a_n=\frac{n-1}{n+1}$.
**** Namig
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
    Uporabi zanko ~for n in range(100):~.
**** Rešitev 
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
    #+BEGIN_SRC python
      for n in range(100):
          print((n-1)/(n+1))
    #+END_SRC
*** Naloga
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: naloga
    :END:
Zaporedje je podano z rekurzivno formulo $$a_{n+1}=\frac{2a_n^3+2}{3a_n^2}$$ in
začetnim členom $a_0=3$. Zapiši prvih 10 členov zaporedja. Kaj opaziš? 
**** Rešitev
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
#+BEGIN_SRC python :results output
  an = 2
  print(an)
  for i in range(9):
      an = (2*an**3+2)/(3*an**2)
      print(an)
#+END_SRC

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example

Členi zaporedja se po 5. členu začnejo ponavljati. Zaporedje je očitno
*konvergentno*. Zadnjih nekaj členov so zelo dobri približki za *limito*.
**** Rešitev z generatorjem
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Za ilustracijo nalogo rešimo še z *generatorjem*. Generator je funkcija, ki je
posebne vrste tip *iteratorja*. *Iterator* je objekt, ki pozna metodo ~next()~
in ga lahko uporabimo v ~for~ zanki. Funkcijo spremenimo v *generator* z uporabo
ukaza ~yield~, ki je zelo podoben ukazu ~return~, le da se ob njegovem klicu
izvajanje funkcije zamrzne do naslednjega klica metode ~next()~. Z generatorjem
na ta način lahko definiramo tudi neskončna zaporedja oziroma zaporedja
poljubnih dolžin. 

#+BEGIN_SRC python :results output
  def zaporedje(n):
      "Generator za prvih n členov zaporedja an"
      an = 2
      while n>0:
          yield an
          an = (2*an**3+2)/(3*an**2)
          n -= 1

  for clen in zaporedje(10):
      print(clen)
#+END_SRC

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example
**** Rešitev z rekurzijo
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Zaporedje $a_n$ lahko definiramo tudi z rekurzivno funkcijo. Paziti moramo le,
da znotraj funkcije opravimo le en klic na isto funkcijo, sicer časovna
zahtevnost eksponentno narašča.
#+BEGIN_SRC python :results output
  def zaporedje(n):
      "Rekurzivna funkcija, ki definira rekurzivno zaporedje"
      if n<=0:
          return 2
      else:
          an = zaporedje(n-1)
          return (2*an**3+2)/(3*an**2) 

  for n in range(10):
      print(zaporedje(n))
#+END_SRC  

#+RESULTS:
#+begin_example
2
1.5
1.2962962962962963
1.2609322247417485
1.2599218605659261
1.2599210498953948
1.259921049894873
1.2599210498948732
1.259921049894873
1.2599210498948732
#+end_example

Kljub temu, da smo se z enim rekurzivnim klicem funkcije izognili eksponentni
časovni odvisnosti, je pri večkratnih klicih funkcije ~zaporedje~ še vedno
precej odvečnih izračunov. Ob vsakem zaporednem klicu funkcije ponovno
izračunamo vse člene od prvega naprej. Časovna zahtevnost ~for~ zanke je tako
kvadratična, medtem ko je pri prejšnjih rešitvah časovna zahtevnost linearna. 
*** Naloga
    :PROPERTIES:
    :HTML_CONTAINER_CLASS: naloga
    :END:
Za zaporedje $$a_n=\frac{n^2+n-1}{1-2n^2},$$ poišči prvi člen $a_n$, ki se za
manj kot
$\varepsilon=\frac{1}{100}$ razlikuje od limite.
**** Namig
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Poišči najmanjše naravno število $n$, da bo $|a_n-a|<\varepsilon$, kjer je  
$$a=\lim_{n\to\infty}a_n=-\frac{1}{2}.$$ Uporabi zanko ~while~.
**** Rešitev
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
#+BEGIN_SRC python :results output
  n = 0
  a = -0.5
  eps = 0.01
  while abs((n**2+n-1)/(1-2*n**2)-a)>eps:
      n += 1
  print(n)
#+END_SRC

#+RESULTS:
: 50
**** Rešitev z generatorjem
     :PROPERTIES:
     :HTML_CONTAINER_CLASS: resitev
     :END:
Za ilustracijo nalogo rešimo še z *generatorjem*. Generator je funkcija, ki je
posebne vrste tip *iteratorja*. *Iterator* je objekt, ki pozna metodo ~next()~
in ga lahko uporabimo v ~for~ zanki. Funkcijo spremenimo v *generator* z uporabo
ukaza ~yield~, ki je zelo podoben ukazu ~return~, le da se ob 

#+BEGIN_SRC python :results output
  def zaporedje():
      n = 0
      while True:
          yield n, (n**2+n-1)/(1-2*n**2)
          n += 1
  a = -0.5
  eps = 0.01

  for n, clen in zaporedje():
      if abs(clen-a)<eps:
          print(n)
          break
#+END_SRC

#+RESULTS:
: 50

** Vrste
